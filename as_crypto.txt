http://www.bolet.org/TestSSLServer/
https://raw.githubusercontent.com/digitalbazaar/forge/master/js/pkcs12.js
http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/sun/security/pkcs12/PKCS12KeyStore.java
http://gcc.gnu.org/viewvc/gcc/trunk/libjava/classpath/gnu/java/security/hash/?limit_changes=0
https://github.com/CruiserX/sha256_plsql

hashes
md2
md4
md5
sha1
sha2-256/sha2-224
sha2-512/sha2-384
ripemd160
crc32

encryption
rc2
blowfish
idea
des
3des
cast128
aes


PBKDF1

-- to do
ENCRYPT_PBE_MD5DES

declare
  t_key	raw(512);
  t_pt	raw(32767);
  t_et	raw(32767);
  t_dt	raw(32767);
  bmax32 constant number := power( 2, 32 ) - 1;
  bmax64 constant number := power( 2, 64 ) - 1;
  type tp_aes_tab is table of number index by pls_integer;
--
  function bitor( x number, y number )
  return number
  is
  begin
    return x + y - bitand( x, y	);
  end;
--
  function bitxor( x number, y number )
  return number
  is
  begin
    return x + y - 2 * bitand( x, y );
  end;
--
  function shl(	x number, b pls_integer	)
  return number
  is
  begin
    return x * power( 2, b );
  end;
--
  function shr(	x number, b pls_integer	)
  return number
  is
  begin
    return trunc( x / power( 2,	b ) );
  end;
--
  function rol32( x number, b pls_integer )
  return number
  is
    t number;
  begin
    t := bitand( x, bmax32 );
    return bitand( bitor( shl( t, b ), shr( t, 32 - b )	), bmax32 );
  end;
--
  procedure aes_encrypt_key
    ( key varchar2
    , p_encrypt_key out	nocopy tp_aes_tab
    )
  is
    rcon tp_aes_tab;
    t_r	number;
    SS varchar2(512);
    s1 number;
    s2 number;
    s3 number;
    t number;
    Nk pls_integer;
    n pls_integer;
    r pls_integer;
  begin
    SS := '637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0'
       || 'b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b275'
       || '09832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cf'
       || 'd0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2'
       || 'cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdb'
       || 'e0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08'
       || 'ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9e'
       || 'e1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16';
    for	i in 0 .. 255
    loop
      s1 := to_number( substr( SS, i * 2 + 1, 2	), 'XX'	);
      s2 := s1 * 2;
      if s2 >= 256
      then
	s2 := bitxor( s2, 283 );
      end if;
      s3 := bitxor( s1,	s2 );
--dbms_output.put_line(	i || ' ' || s1 || ' ' || s2 || ' ' || s3 );
      p_encrypt_key(i) := s1;
      t	:= bitor( bitor( bitor(	shl( s2, 24 ), shl( s1,	16 ) ),	shl( s1, 8 ) ),	s3 );
      p_encrypt_key( 256 + i ) := t;
      t	:= rol32( t, 24	);
      p_encrypt_key( 512 + i ) := t;
      t	:= rol32( t, 24	);
      p_encrypt_key( 768 + i ) := t;
      t	:= rol32( t, 24	);
      p_encrypt_key( 1024 + i )	:= t;
--dbms_output.put_line(	i || ' ' || to_char( Te0(i), 'fm0xxxxxxx' ) || ' ' || to_char( Te1(i), 'fm0xxxxxxx' ) || ' ' ||	to_char( Te2(i), 'fm0xxxxxxx' )	|| ' ' || to_char( Te3(i), 'fm0xxxxxxx'	) );
    end	loop;
--
    t_r	:= 1;
    rcon(0) := shl( t_r, 24 );
--dbms_output.put_line(	'rcon '	|| 0 ||	' ' || rcon(0) );
    for	i in 1 .. 9
    loop
      t_r := t_r * 2;
      if t_r >=	256
      then
	t_r := bitxor( t_r, 283	);
      end if;
      rcon(i) := shl( t_r, 24 );
--dbms_output.put_line(	'rcon '	|| i ||	' ' || t_r || '	' || rcon(i) );
    end	loop;
    rcon(7) := - rcon(7);
--dbms_output.put_line(	'rcon '	|| 7 ||	' ' || rcon(7) );
    Nk := length( key )	/ 8;
    for	i in 0 .. Nk - 1
    loop
      p_encrypt_key( 1280 + i )	:= to_number( substr( key, i * 8 + 1, 8	), 'xxxxxxxx' );
--dbms_output.put_line(	i || ' ' || to_char( p_rk(i), 'fm0xxxxxxx' ) );
    end	loop;
    n := 0;
    r := 0;
    for	i in Nk	.. Nk *	4 + 27
    loop
      t	:= p_encrypt_key( 1280 + i - 1 );
      if n = 0
      then
	n := Nk;
	t := bitor( bitor( shl(	p_encrypt_key( bitand( shr( t, 16 ), 255 ) ), 24 )
			 , shl(	p_encrypt_key( bitand( shr( t, 8  ), 255 ) ), 16 )
			 )
		  , bitor( shl(	p_encrypt_key( bitand( t	   , 255 ) ), 8	)
			 ,	p_encrypt_key( bitand( shr( t, 24 ), 255 ) )
			 )
		  );
	t := bitxor( t,	rcon( r	) );
	r := r + 1;
      elsif ( Nk = 8 and n = 4 )
      then
	t := bitor( bitor( shl(	p_encrypt_key( bitand( shr( t, 24 ), 255 ) ), 24 )
			 , shl(	p_encrypt_key( bitand( shr( t, 16 ), 255 ) ), 16 )
			 )
		  , bitor( shl(	p_encrypt_key( bitand( shr( t, 8  ), 255 ) ), 8	)
			 ,	p_encrypt_key( bitand( t	   , 255 ) )
			 )
		  );
      end if;
      n	:= n -1;
      p_encrypt_key( 1280 + i )	:= bitand( bitxor( p_encrypt_key( 1280 + i - Nk	), t ),	bmax32 );
--dbms_output.put_line(	i || ' ' || to_char( p_rk(i), 'fm0xxxxxxx' ) );
    end	loop;
  end;
--
  procedure aes_decrypt_key
    ( key varchar2
    , p_decrypt_key out	nocopy tp_aes_tab
    )
is
    Se tp_aes_tab;
    rek	tp_aes_tab;
    rcon tp_aes_tab;
    SS varchar2(512);
    s1 number;
    s2 number;
    s3 number;
    i2 number;
    i4 number;
    i8 number;
    i9 number;
    ib number;
    id number;
    ie number;
    t number;
    Nk pls_integer;
    Nw pls_integer;
    n pls_integer;
    r pls_integer;
  begin
    SS := '637c777bf26b6fc53001672bfed7ab76ca82c97dfa5947f0add4a2af9ca472c0'
       || 'b7fd9326363ff7cc34a5e5f171d8311504c723c31896059a071280e2eb27b275'
       || '09832c1a1b6e5aa0523bd6b329e32f8453d100ed20fcb15b6acbbe394a4c58cf'
       || 'd0efaafb434d338545f9027f503c9fa851a3408f929d38f5bcb6da2110fff3d2'
       || 'cd0c13ec5f974417c4a77e3d645d197360814fdc222a908846eeb814de5e0bdb'
       || 'e0323a0a4906245cc2d3ac629195e479e7c8376d8dd54ea96c56f4ea657aae08'
       || 'ba78252e1ca6b4c6e8dd741f4bbd8b8a703eb5664803f60e613557b986c11d9e'
       || 'e1f8981169d98e949b1e87e9ce5528df8ca1890dbfe6426841992d0fb054bb16';
    for	i in 0 .. 255
    loop
      s1 := to_number( substr( SS, i * 2 + 1, 2	), 'XX'	);
      i2 := i *	2;
      if i2 >= 256
      then
	i2 := bitxor( i2, 283 );
      end if;
      i4 := i2 * 2;
      if i4 >= 256
      then
	i4 := bitxor( i4, 283 );
      end if;
      i8 := i4 * 2;
      if i8 >= 256
      then
	i8 := bitxor( i8, 283 );
      end if;
      i9 := bitxor( i8,	i );
      ib := bitxor( i9,	i2 );
      id := bitxor( i9,	i4 );
      ie := bitxor( bitxor( i8,	i4 ), i2 );
      Se(i) := s1;
      p_decrypt_key( s1	) := i;
      t	:= bitor( bitor( bitor(	shl( ie, 24 ), shl( i9,	16 ) ),	shl( id, 8 ) ),	ib );
      p_decrypt_key( 256 + s1 )	:= t;
      t	:= rol32( t, 24	);
      p_decrypt_key( 512 + s1 )	:= t;
      t	:= rol32( t, 24	);
      p_decrypt_key( 768 + s1 )	:= t;
      t	:= rol32( t, 24	);
      p_decrypt_key( 1024 + s1 ) := t;
--dbms_output.put_line(	s1 || '	' || to_char( Te0(s1), 'fm0xxxxxxx' ) || ' ' ||	to_char( Te1(s1), 'fm0xxxxxxx' ) || ' '	|| to_char( Te2(s1), 'fm0xxxxxxx' ) || ' ' || to_char( Te3(s1),	'fm0xxxxxxx' ) );
    end	loop;
--
    t := 1;
    rcon(0) := shl( t, 24 );
--dbms_output.put_line(	'rcon '	|| 0 ||	' ' || rcon(0) );
    for	i in 1 .. 9
    loop
      t	:= t * 2;
      if t >= 256
      then
	t := bitxor( t,	283 );
      end if;
      rcon(i) := shl( t, 24 );
    end	loop;
    rcon(7) := - rcon(7);
--dbms_output.put_line(	'rcon '	|| 7 ||	' ' || rcon(7) );
    Nk := length( key )	/ 8;
    Nw := 4 * (	Nk + 7 );
    for	i in 0 .. Nk - 1
    loop
      rek(i) :=	to_number( substr( key,	i * 8 +	1, 8 ),	'xxxxxxxx' );
    end	loop;
    n := 0;
    r := 0;
    for	i in Nk	.. Nw -	1
    loop
      t	:= rek(i - 1);
      if n = 0
      then
	n := Nk;
	t := bitor( bitor( shl(	Se( bitand( shr( t, 16 ), 255 )	), 24 )
			 , shl(	Se( bitand( shr( t, 8  ), 255 )	), 16 )
			 )
		  , bitor( shl(	Se( bitand( t		, 255 )	), 8 )
			 ,	Se( bitand( shr( t, 24 ), 255 )	)
			 )
		  );
	t := bitxor( t,	rcon( r	) );
	r := r + 1;
      elsif ( Nk = 8 and n = 4 )
      then
	t := bitor( bitor( shl(	Se( bitand( shr( t, 24 ), 255 )	), 24 )
			 , shl(	Se( bitand( shr( t, 16 ), 255 )	), 16 )
			 )
		  , bitor( shl(	Se( bitand( shr( t, 8  ), 255 )	), 8 )
			 ,	Se( bitand( t		, 255 )	)
			 )
		  );
      end if;
      n	:= n -1;
      rek(i) :=	bitand(	bitxor(	rek( i - Nk ), t ), bmax32 );
    end	loop;
    for	i in 0 .. 3
    loop
      p_decrypt_key( 1280 + i )	:= rek(Nw - 4 +	i);
    end	loop;
--dbms_output.put_line(	s1 || '	' || to_char( Te0(s1), 'fm0xxxxxxx' ) || ' ' ||	to_char( Te1(s1), 'fm0xxxxxxx' ) || ' '	|| to_char( Te2(s1), 'fm0xxxxxxx' ) || ' ' || to_char( Te3(s1),	'fm0xxxxxxx' ) );
    for	i in 1 .. Nk + 5
    loop
      for j in 0 .. 3
      loop
	t:= rek( Nw - i	* 4 - 4	+ j );
	t := bitxor( bitxor( p_decrypt_key( 256	+ bitand( Se( bitand( shr( t, 24 ), 255	) ), 255 ) )
			   , p_decrypt_key( 512	+ bitand( Se( bitand( shr( t, 16 ), 255	) ), 255 ) )
			   )
		   , bitxor( p_decrypt_key( 768	+ bitand( Se( bitand( shr( t, 8	), 255 ) ), 255	) )
			   , p_decrypt_key( 1024 + bitand( Se( bitand( t, 255 )	), 255 ) )
			   )
		   );
	p_decrypt_key( 1280 + i	* 4 + j	) := t;
      end loop;
    end	loop;
    for	i in Nw	- 4 .. Nw - 1
    loop
      p_decrypt_key( 1280 + i )	:= rek(i - Nw +	4);
    end	loop;
  end;
--
  function aes_encrypt
    ( src varchar2
    , klen pls_integer
    , p_decrypt_key tp_aes_tab
    )
  return raw
  is
    t0 number;
    t1 number;
    t2 number;
    t3 number;
    a0 number;
    a1 number;
    a2 number;
    a3 number;
    k pls_integer := 0;
--
    function grv( a number, b number, c	number,	d number, v number )
    return varchar2
    is
      t	number;
      rv varchar2(256);
    begin
      t	:= bitxor( p_decrypt_key( bitand( shr( a, 24 ),	255 ) ), shr( v, 24 ) );
      rv := substr( to_char( t,	'0xxxxxxx' ), -2 );
      t	:= bitxor( p_decrypt_key( bitand( shr( b, 16 ),	255 ) ), shr( v, 16 ) );
      rv := rv || substr( to_char( t, '0xxxxxxx' ), -2 );
      t	:= bitxor( p_decrypt_key( bitand( shr( c, 8 ), 255 ) ),	shr( v,	8 ) );
      rv := rv || substr( to_char( t, '0xxxxxxx' ), -2 );
      t	:= bitxor( p_decrypt_key( bitand( d, 255 ) ), v	);
      return rv	|| substr( to_char( t, '0xxxxxxx' ), -2	);
    end;
  begin
    t0 := bitxor( to_number( substr( src,  1, 8	), 'xxxxxxxx' ), p_decrypt_key(	1280 ) );
    t1 := bitxor( to_number( substr( src,  9, 8	), 'xxxxxxxx' ), p_decrypt_key(	1281 ) );
    t2 := bitxor( to_number( substr( src, 17, 8	), 'xxxxxxxx' ), p_decrypt_key(	1282 ) );
    t3 := bitxor( to_number( substr( src, 25, 8	), 'xxxxxxxx' ), p_decrypt_key(	1283 ) );
--dbms_output.put_line(	to_char( t0, 'fm0xxxxxxx' ) || ' ' || to_char( t1, 'fm0xxxxxxx'	) || ' ' || to_char( t2, 'fm0xxxxxxx' )	|| ' ' || to_char( t3, 'fm0xxxxxxx' ) );
    for	i in 1 .. klen / 4 + 5
    loop
      k	:= k + 4;
      a0 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t0, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t1, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t2, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(    t3	    , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	)
		  );
      a1 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t1, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t2, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t3, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(     t0     , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	+ 1 )
		  );
      a2 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t2, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t3, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t0, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(     t1     , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	+ 2 )
		  );
      a3 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t3, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t0, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t1, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(     t2     , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	+ 3 )
		  );
      t0 := a0;	t1 := a1; t2 :=	a2; t3 := a3;
--dbms_output.put_line(	i || ' ' || to_char( t0, 'fm0xxxxxxx' )	|| ' ' || to_char( t1, 'fm0xxxxxxx' ) || ' ' ||	to_char( t2, 'fm0xxxxxxx' ) || ' ' || to_char( t3, 'fm0xxxxxxx'	) );
    end	loop;
    k := k + 4;
    return grv(	t0, t1,	t2, t3,	p_decrypt_key( 1280 + k	) )
	|| grv(	t1, t2,	t3, t0,	p_decrypt_key( 1280 + k	+ 1 ) )
	|| grv(	t2, t3,	t0, t1,	p_decrypt_key( 1280 + k	+ 2 ) )
	|| grv(	t3, t0,	t1, t2,	p_decrypt_key( 1280 + k	+ 3 ) );
  end;
--
  function aes_decrypt
    ( src varchar2
    , klen pls_integer
    , p_decrypt_key tp_aes_tab
    )
  return raw
  is
    t0 number;
    t1 number;
    t2 number;
    t3 number;
    a0 number;
    a1 number;
    a2 number;
    a3 number;
    k pls_integer := 0;
--
    function grv( a number, b number, c	number,	d number, v number )
    return varchar2
    is
      t	number;
      rv varchar2(256);
    begin
      t	:= bitxor( p_decrypt_key( bitand( shr( a, 24 ),	255 ) ), shr( v, 24 ) );
      rv := substr( to_char( t,	'0xxxxxxx' ), -2 );
      t	:= bitxor( p_decrypt_key( bitand( shr( b, 16 ),	255 ) ), shr( v, 16 ) );
      rv := rv || substr( to_char( t, '0xxxxxxx' ), -2 );
      t	:= bitxor( p_decrypt_key( bitand( shr( c, 8 ), 255 ) ),	shr( v,	8 ) );
      rv := rv || substr( to_char( t, '0xxxxxxx' ), -2 );
      t	:= bitxor( p_decrypt_key( bitand( d, 255 ) ), v	);
      return rv	|| substr( to_char( t, '0xxxxxxx' ), -2	);
    end;
  begin
    t0 := bitxor( to_number( substr( src,  1, 8	), 'xxxxxxxx' ), p_decrypt_key(	1280 ) );
    t1 := bitxor( to_number( substr( src,  9, 8	), 'xxxxxxxx' ), p_decrypt_key(	1281 ) );
    t2 := bitxor( to_number( substr( src, 17, 8	), 'xxxxxxxx' ), p_decrypt_key(	1282 ) );
    t3 := bitxor( to_number( substr( src, 25, 8	), 'xxxxxxxx' ), p_decrypt_key(	1283 ) );
--dbms_output.put_line(	to_char( t0, 'fm0xxxxxxx' ) || ' ' || to_char( t1, 'fm0xxxxxxx'	) || ' ' || to_char( t2, 'fm0xxxxxxx' )	|| ' ' || to_char( t3, 'fm0xxxxxxx' ) );
    for	i in 1 .. klen / 4 + 5
    loop
      k	:= k + 4;
      a0 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t0, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t3, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t2, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(     t1     , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	)
		  );
      a1 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t1, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t0, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t3, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(     t2     , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	+ 1 )
		  );
      a2 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t2, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t1, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t0, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(     t3     , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	+ 2 )
		  );
      a3 := bitxor( bitxor( bitxor( p_decrypt_key( 256 + bitand( shr( t3, 24 ),	255 ) )
				  , p_decrypt_key( 512 + bitand( shr( t2, 16 ),	255 ) )
				  )
			  , bitxor( p_decrypt_key( 768 + bitand( shr( t1, 8 ), 255 ) )
				  , p_decrypt_key( 1024	+ bitand(     t0     , 255 ) )
				  )
			  )
		  , p_decrypt_key( 1280	+ i * 4	+ 3 )
		  );
      t0 := a0;	t1 := a1; t2 :=	a2; t3 := a3;
--dbms_output.put_line(	i || ' ' || to_char( t0, 'fm0xxxxxxx' )	|| ' ' || to_char( t1, 'fm0xxxxxxx' ) || ' ' ||	to_char( t2, 'fm0xxxxxxx' ) || ' ' || to_char( t3, 'fm0xxxxxxx'	) );
    end	loop;
    k := k + 4;
    return grv(	t0, t3,	t2, t1,	p_decrypt_key( 1280 + k	) )
	|| grv(	t1, t0,	t3, t2,	p_decrypt_key( 1280 + k	+ 1 ) )
	|| grv(	t2, t1,	t0, t3,	p_decrypt_key( 1280 + k	+ 2 ) )
	|| grv(	t3, t2,	t1, t0,	p_decrypt_key( 1280 + k	+ 3 ) );
  end;
--
  function encrypt( src	raw, typ pls_integer, key raw, iv raw := null )
  return raw
  is
    t_decrypt_key tp_aes_tab;
  begin
    aes_encrypt_key( key, t_decrypt_key	);
    return aes_encrypt(	src, utl_raw.length( key ), t_decrypt_key );
  end;
--
  function decrypt( src	raw, typ pls_integer, key raw, iv raw := null )
  return raw
  is
    t_decrypt_key tp_aes_tab;
  begin
    aes_decrypt_key( key, t_decrypt_key	);
    return aes_decrypt(	src, utl_raw.length( key ), t_decrypt_key );
  end;
begin
  t_key	:= '0123456789ABCDEF0123456789ABCDEF';
  t_pt := utl_i18n.string_to_raw( 'dit is test12345', 'AL32UTF8' );
  t_et := encrypt( t_pt, 1, t_key );
dbms_output.put_line( t_et );
  t_dt := decrypt( t_et, 0, t_key );
dbms_output.put_line( utl_i18n.raw_to_char( t_dt, 'AL32UTF8'  )	);
end;


declare
  t_mac	raw(128);
  t_hash raw(128);
  t_type pls_integer;
  t_src	raw(1000);
  t_key	raw(300);
--
    -- Hash Functions
    HASH_MD4	       CONSTANT	PLS_INTEGER	       :=     1;
    HASH_MD5	       CONSTANT	PLS_INTEGER	       :=     2;
    HASH_SH1	       CONSTANT	PLS_INTEGER	       :=     3;
    HASH_SH224	       CONSTANT	PLS_INTEGER	       :=     11;
    HASH_SH256	       CONSTANT	PLS_INTEGER	       :=     4;
    HASH_SH384	       CONSTANT	PLS_INTEGER	       :=     5;
    HASH_SH512	       CONSTANT	PLS_INTEGER	       :=     6;
    HASH_RIPEMD160     CONSTANT	PLS_INTEGER	       :=     15;
    -- MAC Functions
    HMAC_MD4	       CONSTANT	PLS_INTEGER	       :=     0;
    HMAC_MD5	       CONSTANT	PLS_INTEGER	       :=     1;
    HMAC_SH1	       CONSTANT	PLS_INTEGER	       :=     2;
    HMAC_SH224	       CONSTANT	PLS_INTEGER	       :=     10;
    HMAC_SH256	       CONSTANT	PLS_INTEGER	       :=     3;
    HMAC_SH384	       CONSTANT	PLS_INTEGER	       :=     4;
    HMAC_SH512	       CONSTANT	PLS_INTEGER	       :=     5;
    HMAC_RIPEMD160     CONSTANT	PLS_INTEGER	       :=     14;
--
  bmax32 constant number := power( 2, 32 ) - 1;
  bmax64 constant number := power( 2, 64 ) - 1;
  type tp_crypto is table of number;
--
  function bitor( x number, y number )
  return number
  is
  begin
    return x + y - bitand( x, y	);
  end;
--
  function bitxor( x number, y number )
  return number
  is
  begin
    return x + y - 2 * bitand( x, y );
  end;
--
  function shl(	x number, b pls_integer	)
  return number
  is
  begin
    return x * power( 2, b );
  end;
--
  function shr(	x number, b pls_integer	)
  return number
  is
  begin
    return trunc( x / power( 2,	b ) );
  end;
--
  function ror32( x number, b pls_integer )
  return number
  is
    t number;
  begin
    t := bitand( x, bmax32 );
    return bitand( bitor( shr( t, b ), shl( t, 32 - b )	), bmax32 );
  end;
--
  function rol32( x number, b pls_integer )
  return number
  is
    t number;
  begin
    t := bitand( x, bmax32 );
    return bitand( bitor( shl( t, b ), shr( t, 32 - b )	), bmax32 );
  end;
--
  function ror64( x number, b pls_integer )
  return number
  is
    t number;
  begin
    t := bitand( x, bmax64 );
    return bitand( bitor( shr( t, b ), shl( t, 64 - b )	), bmax64 );
  end;
--
  function rol64( x number, b pls_integer )
  return number
  is
    t number;
  begin
    t := bitand( x, bmax64 );
    return bitand( bitor( shl( t, b ), shr( t, 64 - b )	), bmax64 );
  end;
--
  function ripemd160( p_msg raw	)
  return raw
  is
    t_md varchar2(128);
    fmt2 varchar2(10) := 'fm0XXXXXXX';
    t_len pls_integer;
    t_pad_len pls_integer;
    t_pad varchar2(144);
    t_msg_buf varchar2(32766);
    t_idx pls_integer;
    t_chunksize	pls_integer := 16320; -- 255 * 64
    t_block varchar2(128);
--
    st tp_crypto;
    sl tp_crypto;
    sr tp_crypto;
--
    procedure ff( a in out number, b number, c in out number, d	number,	e number, xi pls_integer, r pls_integer	)
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= bitand( rol32( a + bitxor( bitxor( b, c ), d	) + x, r ) + e,	bmax32 );
      c	:= rol32( c, 10	);
    end;
--
    procedure ll( a in out number, b number, c in out number, d	number,	e number, xi pls_integer, r pls_integer, h number )
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= bitand( rol32( a + bitxor( b, bitor(	c, - d - 1 ) ) + x + h,	r ) + e, bmax32	);
      c	:= rol32( c, 10	);
    end;
--
    procedure gg( a in out number, b number, c in out number, d	number,	e number, xi pls_integer, r pls_integer, h number )
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= bitand( rol32( a + bitor( bitand( b,	c ), bitand( - b - 1, d	) ) + x	+ h, r ) + e, bmax32 );
      c	:= rol32( c, 10	);
    end;
--
    procedure kk( a in out number, b number, c in out number, d	number,	e number, xi pls_integer, r pls_integer, h number )
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= bitand( rol32( a + bitor( bitand( b,	d ), bitand( c,	- d - 1	) ) + x	+ h, r ) + e, bmax32 );
      c	:= rol32( c, 10	);
    end;
--
    procedure hh( a in out number, b number, c in out number, d	number,	e number, xi pls_integer, r pls_integer, h number )
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= bitand( rol32( a + bitxor( bitor( b,	- c - 1	), d ) + x + h,	r ) + e, bmax32	);
      c	:= rol32( c, 10	);
    end;
--
    procedure fa( ar in	out tp_crypto, s pls_integer, xis tp_crypto, r_cnt tp_crypto )
    is
    begin
      for i in 1 .. 16
      loop
	ff( ar(mod(15-i+s,5)+1),ar(mod(16-i+s,5)+1),ar(mod(17-i+s,5)+1),ar(mod(18-i+s,5)+1),ar(mod(19-i+s,5)+1),xis(i),r_cnt(i)	);
      end loop;
    end;
    procedure ga( ar in	out tp_crypto, s pls_integer, h	number,	xis tp_crypto, r_cnt tp_crypto )
    is
    begin
      for i in 1 .. 16
      loop
	gg( ar(mod(15-i+s,5)+1),ar(mod(16-i+s,5)+1),ar(mod(17-i+s,5)+1),ar(mod(18-i+s,5)+1),ar(mod(19-i+s,5)+1),xis(i),r_cnt(i), h );
      end loop;
    end;
    procedure ha( ar in	out tp_crypto, s pls_integer, h	number,	xis tp_crypto, r_cnt tp_crypto )
    is
    begin
      for i in 1 .. 16
      loop
	hh( ar(mod(15-i+s,5)+1),ar(mod(16-i+s,5)+1),ar(mod(17-i+s,5)+1),ar(mod(18-i+s,5)+1),ar(mod(19-i+s,5)+1),xis(i),r_cnt(i), h );
      end loop;
    end;
    procedure ka( ar in	out tp_crypto, s pls_integer, h	number,	xis tp_crypto, r_cnt tp_crypto )
    is
    begin
      for i in 1 .. 16
      loop
	kk( ar(mod(15-i+s,5)+1),ar(mod(16-i+s,5)+1),ar(mod(17-i+s,5)+1),ar(mod(18-i+s,5)+1),ar(mod(19-i+s,5)+1),xis(i),r_cnt(i), h );
      end loop;
    end;
    procedure la( ar in	out tp_crypto, s pls_integer, h	number,	xis tp_crypto, r_cnt tp_crypto )
    is
    begin
      for i in 1 .. 16
      loop
	ll( ar(mod(15-i+s,5)+1),ar(mod(16-i+s,5)+1),ar(mod(17-i+s,5)+1),ar(mod(18-i+s,5)+1),ar(mod(19-i+s,5)+1),xis(i),r_cnt(i), h );
      end loop;
    end;
  begin
    t_len := nvl( utl_raw.length( p_msg	), 0 );
    t_pad_len := 64 - mod( t_len, 64 );
    if t_pad_len < 9
    then
      t_pad_len	:= 64 +	t_pad_len;
    end	if;
    t_pad := rpad( '8',	t_pad_len * 2 -	16, '0'	)
       || utl_raw.cast_from_binary_integer( t_len * 8, utl_raw.little_endian )
       || '00000000';
--
    st := tp_crypto( 1732584193	-- 67452301
		   , 4023233417	-- efcdab89
		   , 2562383102	-- 98badcfe
		   ,  271733878	-- 10325476
		   , 3285377520	-- c3d2e1f0
		   );
--
    sl := tp_crypto( 0,	0, 0, 0, 0 );
    sr := tp_crypto( 0,	0, 0, 0, 0 );
--
    t_idx := 1;
    while t_idx	<= t_len + t_pad_len
    loop
      if t_len - t_idx + 1 >= t_chunksize
      then
	t_msg_buf := utl_raw.substr( p_msg, t_idx, t_chunksize );
	t_idx := t_idx + t_chunksize;
      else
	if t_idx <= t_len
	then
	  t_msg_buf := utl_raw.substr( p_msg, t_idx );
	  t_idx	:= t_len + 1;
	else
	  t_msg_buf := '';
	end if;
	if nvl(	length(	t_msg_buf ), 0 ) + t_pad_len * 2 <= 32766
	then
	  t_msg_buf := t_msg_buf || t_pad;
	  t_idx	:= t_idx + t_pad_len;
	end if;
      end if;
      for i in 1 .. length( t_msg_buf )	/ 128
      loop
	t_block	:= substr( t_msg_buf, i	* 128 -	127, 128 );
--
	for i in 1 .. 5
	loop
	 sl(i) := st(i);
	 sr(i) := st(i);
	end loop;
--
	fa( sl,	1
	  , tp_crypto( 0, 1, 2,	3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15 )
	  , tp_crypto(11,14,15,12, 5, 8, 7, 9,11,13,14,15, 6, 7, 9, 8 )
	  );
	ga( sl,	5, 1518500249 -- 5a827999
	  , tp_crypto( 7, 4,13,	1,10, 6,15, 3,12, 0, 9,	5, 2,14,11, 8 )
	  , tp_crypto( 7, 6, 8,13,11, 9, 7,15, 7,12,15,	9,11, 7,13,12 )
	  );
	ha( sl,	4, 1859775393  -- 6ed9eba1
	  , tp_crypto( 3,10,14,	4, 9,15, 8, 1, 2, 7, 0,	6,13,11, 5,12 )
	  , tp_crypto(11,13, 6,	7,14, 9,13,15,14, 8,13,	6, 5,12, 7, 5 )
	  );
	ka( sl,	3, 2400959708  -- 8f1bbcdc
	  , tp_crypto( 1, 9,11,10, 0, 8,12, 4,13, 3, 7,15,14, 5, 6, 2 )
	  , tp_crypto(11,12,14,15,14,15, 9, 8, 9,14, 5,	6, 8, 6, 5,12 )
	  );
	la( sl,	2, 2840853838  -- a953fd4e
	  , tp_crypto( 4, 0, 5,	9, 7,12, 2,10,14, 1, 3,	8,11, 6,15,13 )
	  , tp_crypto( 9,15, 5,11, 6, 8,13,12, 5,12,13,14,11, 8, 5, 6 )
	  );
--
	la( sr,	1, 1352829926  -- 50a28be6
	  , tp_crypto( 5,14, 7,	0, 9, 2,11, 4,13, 6,15,	8, 1,10, 3,12 )
	  , tp_crypto( 8, 9, 9,11,13,15,15, 5, 7, 7, 8,11,14,14,12, 6 )
	  );
	ka( sr,	5, 1548603684  -- 5c4dd124
	  , tp_crypto( 6,11, 3,	7, 0,13, 5,10,14,15, 8,12, 4, 9, 1, 2 )
	  , tp_crypto( 9,13,15,	7,12, 8, 9,11, 7, 7,12,	7, 6,15,13,11 )
	  );
	ha( sr,	4, 1836072691  -- 6d703ef3
	  , tp_crypto(15, 5, 1,	3, 7,14, 6, 9,11, 8,12,	2,10, 0, 4,13 )
	  , tp_crypto( 9, 7,15,11, 8, 6, 6,14,12,13, 5,14,13,13, 7, 5 )
	  );
	ga( sr,	3, 2053994217  -- 7a6d76e9
	  , tp_crypto( 8, 6, 4,	1, 3,11,15, 0, 5,12, 2,13, 9, 7,10,14 )
	  , tp_crypto(15, 5, 8,11,14,14, 6,14, 6, 9,12,	9,12, 5,15, 8 )
	  );
	fa( sr,	2
	  , tp_crypto(12,15,10,	4, 1, 5, 8, 7, 6, 2,13,14, 0, 3, 9,11 )
	  , tp_crypto( 8, 5,12,	9,12, 5,14, 6, 8,13, 6,	5,15,13,11,11 )
	  );
--dbms_output.put_line(	to_char(sr(1),fmt2) || ' ' ||to_char(sr(2),fmt2) || ' '	||to_char(sr(3),fmt2) || ' ' ||to_char(sr(4),fmt2) || '	' ||to_char(sr(5),fmt2)	);
--
	sl(2) := bitand( sl(2) + st(1) + sr(3),	bmax32 );
	st(1) := bitand( st(2) + sl(3) + sr(4),	bmax32 );
	st(2) := bitand( st(3) + sl(4) + sr(5),	bmax32 );
	st(3) := bitand( st(4) + sl(5) + sr(1),	bmax32 );
	st(4) := bitand( st(5) + sl(1) + sr(2),	bmax32 );
	st(5) := sl(2);
--
      end loop;
    end	loop;
--
    t_md := utl_raw.reverse( to_char( st(1), fmt2 ) )
	 || utl_raw.reverse( to_char( st(2), fmt2 ) )
	 || utl_raw.reverse( to_char( st(3), fmt2 ) )
	 || utl_raw.reverse( to_char( st(4), fmt2 ) )
	 || utl_raw.reverse( to_char( st(5), fmt2 ) );
--
    return t_md;
  end;
--
  function md4(	p_msg raw )
  return raw
  is
    t_md varchar2(128);
    fmt1 varchar2(10) := 'XXXXXXXX';
    fmt2 varchar2(10) := 'fm0XXXXXXX';
    t_len pls_integer;
    t_pad_len pls_integer;
    t_pad varchar2(144);
    t_msg_buf varchar2(32766);
    t_idx pls_integer;
    t_chunksize	pls_integer := 16320; -- 255 * 64
    t_block varchar2(128);
    a number;
    b number;
    c number;
    d number;
    AA number;
    BB number;
    CC number;
    DD number;
--
    procedure ff( a in out number, b number, c number, d number, xi number, s pls_integer )
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= a + bitor( bitand( b, c ), bitand( -	b - 1, d ) ) + x;
      a	:= rol32( a, s );
    end;
--
    procedure gg( a in out number, b number, c number, d number, xi number, s pls_integer )
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= a + bitor( bitor( bitand( b,	c ), bitand( b,	d ) ), bitand( c, d ) )	+ x + 1518500249; -- to_number(	'5a827999', 'xxxxxxxx' );
      a	:= rol32( a, s );
    end;
--
    procedure hh( a in out number, b number, c number, d number, xi number, s pls_integer )
    is
      x	number := utl_raw.cast_to_binary_integer( substr( t_block, xi *	8 + 1, 8 ), utl_raw.little_endian );
    begin
      a	:= a + bitxor( bitxor( b, c ), d ) + x + 1859775393; --	to_number( '6ed9eba1', 'xxxxxxxx' );
      a	:= rol32( a, s );
    end;
--
  begin
    t_len := nvl( utl_raw.length( p_msg	), 0 );
    t_pad_len := 64 - mod( t_len, 64 );
    if t_pad_len < 9
    then
      t_pad_len	:= 64 +	t_pad_len;
    end	if;
    t_pad := rpad( '8',	t_pad_len * 2 -	16, '0'	)
       || utl_raw.cast_from_binary_integer( t_len * 8, utl_raw.little_endian )
       || '00000000';
--
    AA := to_number( '67452301', fmt1 );
    BB := to_number( 'efcdab89', fmt1 );
    CC := to_number( '98badcfe', fmt1 );
    DD := to_number( '10325476', fmt1 );
--
    t_idx := 1;
    while t_idx	<= t_len + t_pad_len
    loop
      if t_len - t_idx + 1 >= t_chunksize
      then
	t_msg_buf := utl_raw.substr( p_msg, t_idx, t_chunksize );
	t_idx := t_idx + t_chunksize;
      else
	if t_idx <= t_len
	then
	  t_msg_buf := utl_raw.substr( p_msg, t_idx );
	  t_idx	:= t_len + 1;
	else
	  t_msg_buf := '';
	end if;
	if nvl(	length(	t_msg_buf ), 0 ) + t_pad_len * 2 <= 32766
	then
	  t_msg_buf := t_msg_buf || t_pad;
	  t_idx	:= t_idx + t_pad_len;
	end if;
      end if;
      for i in 1 .. length( t_msg_buf )	/ 128
      loop
	t_block	:= substr( t_msg_buf, i	* 128 -	127, 128 );
	a := AA;
	b := BB;
	c := CC;
	d := DD;
--
	for j in 0 .. 3
	loop
	  ff( a, b, c, d, j * 4	+ 0, 3 );
	  ff( d, a, b, c, j * 4	+ 1, 7 );
	  ff( c, d, a, b, j * 4	+ 2, 11	);
	  ff( b, c, d, a, j * 4	+ 3, 19	);
	end loop;
--
	for j in 0 .. 3
	loop
	  gg( a, b, c, d, j + 0, 3 );
	  gg( d, a, b, c, j + 4, 5 );
	  gg( c, d, a, b, j + 8, 9 );
	  gg( b, c, d, a, j + 12, 13 );
	end loop;
--
	for j in 0 .. 3
	loop
	  hh( a, b, c, d, bitand( j, 1 ) * 2 + bitand( j, 2 ) /	2 + 0, 3 );
	  hh( d, a, b, c, bitand( j, 1 ) * 2 + bitand( j, 2 ) /	2 + 8, 9 );
	  hh( c, d, a, b, bitand( j, 1 ) * 2 + bitand( j, 2 ) /	2 + 4, 11 );
	  hh( b, c, d, a, bitand( j, 1 ) * 2 + bitand( j, 2 ) /	2 + 12,	15 );
	end loop;
--
	AA := bitand( AA + a, bmax32 );
	BB := bitand( BB + b, bmax32 );
	CC := bitand( CC + c, bmax32 );
	DD := bitand( DD + d, bmax32 );
      end loop;
    end	loop;
--
    t_md := utl_raw.reverse( to_char( AA, fmt2 ) )
	 || utl_raw.reverse( to_char( BB, fmt2 ) )
	 || utl_raw.reverse( to_char( CC, fmt2 ) )
	 || utl_raw.reverse( to_char( DD, fmt2 ) );
--
    return t_md;
  end;
--
  function md5(	p_msg raw )
  return raw
  is
    t_md varchar2(128);
    fmt1 varchar2(10) := 'XXXXXXXX';
    fmt2 varchar2(10) := 'fm0XXXXXXX';
    t_len pls_integer;
    t_pad_len pls_integer;
    t_pad varchar2(144);
    t_msg_buf varchar2(32766);
    t_idx pls_integer;
    t_chunksize	pls_integer := 16320; -- 255 * 64
    t_block varchar2(128);
    type tp_tab	is table of number;
    Ht tp_tab;
    K tp_tab;
    s tp_tab;
    H_str varchar2(64);
    K_str varchar2(512);
    a number;
    b number;
    c number;
    d number;
    e number;
    f number;
    g number;
    h number;
  begin
    t_len := nvl( utl_raw.length( p_msg	), 0 );
    t_pad_len := 64 - mod( t_len, 64 );
    if t_pad_len < 9
    then
      t_pad_len	:= 64 +	t_pad_len;
    end	if;
    t_pad := rpad( '8',	t_pad_len * 2 -	16, '0'	)
       || utl_raw.cast_from_binary_integer( t_len * 8, utl_raw.little_endian )
       || '00000000';
--
    s := tp_tab( 7, 12,	17, 22,	 7, 12,	17, 22,	 7, 12,	17, 22,	 7, 12,	17, 22
	       , 5,  9,	14, 20,	 5,  9,	14, 20,	 5,  9,	14, 20,	 5,  9,	14, 20
	       , 4, 11,	16, 23,	 4, 11,	16, 23,	 4, 11,	16, 23,	 4, 11,	16, 23
	       , 6, 10,	15, 21,	 6, 10,	15, 21,	 6, 10,	15, 21,	 6, 10,	15, 21
	       );
--
    H_str := '67452301efcdab8998badcfe10325476';
    Ht := tp_tab();
    Ht.extend(4);
    for	i in 1 .. 4
    loop
      Ht(i) := to_number( substr( H_str, i * 8 - 7, 8 ), fmt1 );
    end	loop;
--
    K_str := 'd76aa478e8c7b756242070dbc1bdceeef57c0faf4787c62aa8304613fd469501'
	  || '698098d88b44f7afffff5bb1895cd7be6b901122fd987193a679438e49b40821'
	  || 'f61e2562c040b340265e5a51e9b6c7aad62f105d02441453d8a1e681e7d3fbc8'
	  || '21e1cde6c33707d6f4d50d87455a14eda9e3e905fcefa3f8676f02d98d2a4c8a'
	  || 'fffa39428771f6816d9d6122fde5380ca4beea444bdecfa9f6bb4b60bebfbc70'
	  || '289b7ec6eaa127fad4ef308504881d05d9d4d039e6db99e51fa27cf8c4ac5665'
	  || 'f4292244432aff97ab9423a7fc93a039655b59c38f0ccc92ffeff47d85845dd1'
	  || '6fa87e4ffe2ce6e0a30143144e0811a1f7537e82bd3af2352ad7d2bbeb86d391';
    K := tp_tab();
    K.extend(64);
    for	i in 1 .. 64
    loop
      K(i) := to_number( substr( K_str,	i * 8 -	7, 8 ),	fmt1 );
    end	loop;
    t_idx := 1;
    while t_idx	<= t_len + t_pad_len
    loop
      if t_len - t_idx + 1 >= t_chunksize
      then
	t_msg_buf := utl_raw.substr( p_msg, t_idx, t_chunksize );
	t_idx := t_idx + t_chunksize;
      else
	if t_idx <= t_len
	then
	  t_msg_buf := utl_raw.substr( p_msg, t_idx );
	  t_idx	:= t_len + 1;
	else
	  t_msg_buf := '';
	end if;
	if nvl(	length(	t_msg_buf ), 0 ) + t_pad_len * 2 <= 32766
	then
	  t_msg_buf := t_msg_buf || t_pad;
	  t_idx	:= t_idx + t_pad_len;
	end if;
      end if;
      for i in 1 .. length( t_msg_buf )	/ 128
      loop
	t_block	:= substr( t_msg_buf, i	* 128 -	127, 128 );
	a := Ht(1);
	b := Ht(2);
	c := Ht(3);
	d := Ht(4);
	for j in 0 .. 63
	loop
	  if j <= 15
	  then
	    F := bitand( bitxor( D, bitand( B, bitxor( C, D ) )	), bmax32 );
	    g := j;
	  elsif	j <= 31
	  then
	    F := bitand( bitxor( C, bitand( D, bitxor( B, C ) )	), bmax32 );
	    g := mod( 5*j + 1, 16 );
	  elsif	j <= 47
	  then
	    F := bitand( bitxor( B, bitxor( C, D ) ), bmax32 );
	    g := mod( 3*j + 5, 16 );
	  else
	    F := bitand( bitxor( C, bitor( B, -	D  - 1 ) ), bmax32 );
	    g := mod( 7*j, 16 );
	  end if;
	  e := D;
	  D := C;
	  C := B;
	  h := utl_raw.cast_to_binary_integer( substr( t_block,	g * 8 +	1, 8 ),	utl_raw.little_endian );
	  B := bitand( B + rol32( bitand( A + F	+ k( j + 1 ) + h, bmax32 ), s( j + 1 ) ), bmax32 );
	  A := e;
	end loop;
	Ht(1) := bitand( Ht(1) + a, bmax32 );
	Ht(2) := bitand( Ht(2) + b, bmax32 );
	Ht(3) := bitand( Ht(3) + c, bmax32 );
	Ht(4) := bitand( Ht(4) + d, bmax32 );
      end loop;
    end	loop;
--
    for	i in 1 .. 4
    loop
      t_md := t_md || utl_raw.reverse( to_char(	Ht(i), fmt2 ) );
    end	loop;
--
    return t_md;
  end;
--
  function sha1( p_val raw )
  return raw
  is
    t_val raw(32767);
    t_len pls_integer;
    t_padding raw(128);
    type tp_n is table of integer index	by pls_integer;
    w tp_n;
    tw tp_n;
    th tp_n;
    c_ffffffff integer := to_number( 'ffffffff', 'xxxxxxxx' );
    c_5A827999 integer := to_number( '5A827999', 'xxxxxxxx' );
    c_6ED9EBA1 integer := to_number( '6ED9EBA1', 'xxxxxxxx' );
    c_8F1BBCDC integer := to_number( '8F1BBCDC', 'xxxxxxxx' );
    c_CA62C1D6 integer := to_number( 'CA62C1D6', 'xxxxxxxx' );
--
    function radd( x integer, y	integer	)
    return integer
    is
    begin
      return x + y;
    end;
--
  begin
    th(0) := to_number(	hextoraw( '67452301' ),	'xxxxxxxx' );
    th(1) := to_number(	hextoraw( 'EFCDAB89' ),	'xxxxxxxx' );
    th(2) := to_number(	hextoraw( '98BADCFE' ),	'xxxxxxxx' );
    th(3) := to_number(	hextoraw( '10325476' ),	'xxxxxxxx' );
    th(4) := to_number(	hextoraw( 'C3D2E1F0' ),	'xxxxxxxx' );
--
    t_len := nvl( utl_raw.length( p_val	), 0 );
    if mod( t_len, 64 )	< 55
    then
      t_padding	:=  utl_raw.concat( hextoraw( '80' ), utl_raw.copies( hextoraw(	'00' ),	55 - mod( t_len, 64 ) )	);
    elsif mod( t_len, 64 ) = 55
    then
      t_padding	:=  hextoraw( '80' );
    else
      t_padding	:=  utl_raw.concat( hextoraw( '80' ), utl_raw.copies( hextoraw(	'00' ),	119 - mod( t_len, 64 ) ) );
    end	if;
    t_padding := utl_raw.concat( t_padding
			       , hextoraw( '00000000' )
			       , utl_raw.cast_from_binary_integer( t_len * 8 ) -- only 32 bits number!!
			       );
    t_val := utl_raw.concat( p_val, t_padding );
    for	c in 0 .. utl_raw.length( t_val	) / 64 - 1
    loop
      for i in 0 .. 15
      loop
	w(i) :=	to_number( utl_raw.substr( t_val, c*64 + i*4 + 1, 4 ), 'xxxxxxxx' );
      end loop;
      for i in 16 .. 79
      loop
	w(i) :=	rol32( bitxor( bitxor( w(i-3), w(i-8) ), bitxor( w(i-14), w(i-16) ) ), 1 );
      end loop;
--
      for i in 0 .. 4
      loop
	tw(i) := th(i);
      end loop;
--
      for i in 0 .. 19
      loop
	tw(4-mod(i,5)) := tw(4-mod(i,5)) + rol32( tw(4-mod(i+4,5)), 5 )
			+ bitor( bitand( tw(4-mod(i+3,5)), tw(4-mod(i+2,5)) )
			       , bitand( c_ffffffff - tw(4-mod(i+3,5)),	tw(4-mod(i+1,5)) )
			       )
			+ w(i) + c_5A827999;
	tw(4-mod(i+3,5)) := rol32( tw( 4-mod(i+3,5)), 30 );
      end loop;
      for i in 20 .. 39
      loop
	tw(4-mod(i,5)) := tw(4-mod(i,5)) + rol32( tw(4-mod(i+4,5)), 5 )
			+ bitxor( bitxor( tw(4-mod(i+3,5)), tw(4-mod(i+2,5)) )
				, tw(4-mod(i+1,5))
				)
			+ w(i) + c_6ED9EBA1;
	tw(4-mod(i+3,5)) := rol32( tw( 4-mod(i+3,5)), 30 );
      end loop;
      for i in 40 .. 59
      loop
	tw(4-mod(i,5)) := tw(4-mod(i,5)) + rol32( tw(4-mod(i+4,5)), 5 )
			+ bitor( bitand( tw(4-mod(i+3,5)), tw(4-mod(i+2,5)) )
			       , bitor(	bitand(	tw(4-mod(i+3,5)), tw(4-mod(i+1,5)) )
					      ,	bitand(	tw(4-mod(i+2,5)), tw(4-mod(i+1,5)) )
					      )
			       )
			+ w(i) + c_8F1BBCDC;
	tw(4-mod(i+3,5)) := rol32( tw( 4-mod(i+3,5)), 30 );
      end loop;
      for i in 60 .. 79
      loop
	tw(4-mod(i,5)) := tw(4-mod(i,5)) + rol32( tw(4-mod(i+4,5)), 5 )
			+ bitxor( bitxor( tw(4-mod(i+3,5)), tw(4-mod(i+2,5)) )
				, tw(4-mod(i+1,5))
				)
			+ w(i) + c_CA62C1D6;
	tw(4-mod(i+3,5)) := rol32( tw( 4-mod(i+3,5)), 30 );
      end loop;
--
      for i in 0 .. 4
      loop
	th(i) := bitand( th(i) + tw(i),	bmax32 );
      end loop;
--
    end	loop;
--
    return utl_raw.concat( to_char( th(0), 'fm0000000X'	)
			 , to_char( th(1), 'fm0000000X'	)
			 , to_char( th(2), 'fm0000000X'	)
			 , to_char( th(3), 'fm0000000X'	)
			 , to_char( th(4), 'fm0000000X'	)
			 );
  end;
--
  function sha256( p_msg raw, p_256 boolean )
  return raw
  is
    t_md varchar2(128);
    fmt1 varchar2(10) := 'xxxxxxxx';
    fmt2 varchar2(10) := 'fm0xxxxxxx';
    t_len pls_integer;
    t_pad_len pls_integer;
    t_pad varchar2(144);
    t_msg_buf varchar2(32766);
    t_idx pls_integer;
    t_chunksize	pls_integer := 16320; -- 255 * 64
    t_block varchar2(128);
    type tp_tab	is table of number;
    Ht tp_tab;
    K tp_tab;
    w tp_tab;
    H_str varchar2(64);
    K_str varchar2(512);
    a number;
    b number;
    c number;
    d number;
    e number;
    f number;
    g number;
    h number;
    s0 number;
    s1 number;
    maj	number;
    ch number;
    t1 number;
    t2 number;
    tmp	number;
  begin
    t_len := nvl( utl_raw.length( p_msg	), 0 );
    t_pad_len := 64 - mod( t_len, 64 );
    if t_pad_len < 9
    then
      t_pad_len	:= 64 +	t_pad_len;
    end	if;
    t_pad := rpad( '8',	t_pad_len * 2 -	8, '0' ) || to_char( t_len * 8,	'fm0XXXXXXX' );
--
    if p_256
    then
      H_str := '6a09e667bb67ae853c6ef372a54ff53a510e527f9b05688c1f83d9ab5be0cd19';
    else
      H_str := 'c1059ed8367cd5073070dd17f70e5939ffc00b316858151164f98fa7befa4fa4';
    end	if;
    Ht := tp_tab();
    Ht.extend(8);
    for	i in 1 .. 8
    loop
      Ht(i) := to_number( substr( H_str, i * 8 - 7, 8 ), fmt1 );
    end	loop;
--
    K_str := '428a2f9871374491b5c0fbcfe9b5dba53956c25b59f111f1923f82a4ab1c5ed5'
	  || 'd807aa9812835b01243185be550c7dc372be5d7480deb1fe9bdc06a7c19bf174'
	  || 'e49b69c1efbe47860fc19dc6240ca1cc2de92c6f4a7484aa5cb0a9dc76f988da'
	  || '983e5152a831c66db00327c8bf597fc7c6e00bf3d5a7914706ca635114292967'
	  || '27b70a852e1b21384d2c6dfc53380d13650a7354766a0abb81c2c92e92722c85'
	  || 'a2bfe8a1a81a664bc24b8b70c76c51a3d192e819d6990624f40e3585106aa070'
	  || '19a4c1161e376c082748774c34b0bcb5391c0cb34ed8aa4a5b9cca4f682e6ff3'
	  || '748f82ee78a5636f84c878148cc7020890befffaa4506cebbef9a3f7c67178f2';
    K := tp_tab();
    K.extend(64);
    for	i in 1 .. 64
    loop
      K(i) := to_number( substr( K_str,	i * 8 -	7, 8 ),	fmt1 );
    end	loop;
--
    t_idx := 1;
    while t_idx	<= t_len + t_pad_len
    loop
      if t_len - t_idx + 1 >= t_chunksize
      then
	t_msg_buf := utl_raw.substr( p_msg, t_idx, t_chunksize );
	t_idx := t_idx + t_chunksize;
      else
	if t_idx <= t_len
	then
	  t_msg_buf := utl_raw.substr( p_msg, t_idx );
	  t_idx	:= t_len + 1;
	else
	  t_msg_buf := '';
	end if;
	if nvl(	length(	t_msg_buf ), 0 ) + t_pad_len * 2 <= 32766
	then
	  t_msg_buf := t_msg_buf || t_pad;
	  t_idx	:= t_idx + t_pad_len;
	end if;
      end if;
--
      for i in 1 .. length( t_msg_buf )	/ 128
      loop
--
	a := Ht(1);
	b := Ht(2);
	c := Ht(3);
	d := Ht(4);
	e := Ht(5);
	f := Ht(6);
	g := Ht(7);
	h := Ht(8);
--
	t_block	:= substr( t_msg_buf, i	* 128 -	127, 128 );
	w := tp_tab();
	w.extend( 64 );
	for j in 1 .. 16
	loop
	  w(j) := to_number( substr( t_block, j	* 8  - 7, 8 ), fmt1 );
	end loop;
--
	for j in 17 .. 64
	loop
	  tmp := w(j-15);
	  s0 :=	bitxor(	bitxor(	ror32( tmp, 7),	ror32( tmp, 18 ) ), shr( tmp, 3	) );
	  tmp := w(j-2);
	  s1 :=	bitxor(	bitxor(	ror32( tmp, 17), ror32(	tmp, 19	) ), shr( tmp, 10 ) );
	  w(j) := bitand( w(j-16) + s0 + w(j-7)	+ s1, bmax32 );
	end loop;
--
	for j in 1 .. 64
	loop
	  s0 :=	bitxor(	bitxor(	ror32( a, 2 ), ror32( a, 13 ) ), ror32(	a, 22 )	);
	  maj := bitxor( bitxor( bitand( a, b ), bitand( a, c )	), bitand( b, c	) );
	  t2 :=	bitand(	s0 + maj, bmax32 );
	  s1 :=	bitxor(	bitxor(	ror32( e, 6 ), ror32( e, 11 ) ), ror32(	e, 25 )	);
	  ch :=	bitxor(	bitand(	e, f ),	bitand(	- e - 1, g ) );
	  t1 :=	h + s1 + ch + K(j) + w(j);
	  h := g;
	  g := f;
	  f := e;
	  e := d + t1;
	  d := c;
	  c := b;
	  b := a;
	  a := t1 + t2;
	end loop;
--
	Ht(1) := bitand( Ht(1) + a, bmax32 );
	Ht(2) := bitand( Ht(2) + b, bmax32 );
	Ht(3) := bitand( Ht(3) + c, bmax32 );
	Ht(4) := bitand( Ht(4) + d, bmax32 );
	Ht(5) := bitand( Ht(5) + e, bmax32 );
	Ht(6) := bitand( Ht(6) + f, bmax32 );
	Ht(7) := bitand( Ht(7) + g, bmax32 );
	Ht(8) := bitand( Ht(8) + h, bmax32 );
--
      end loop;
    end	loop;
    for	i in 1 .. case when p_256 then 8 else 7	end
    loop
      t_md := t_md || to_char( Ht(i), fmt2 );
    end	loop;
    return t_md;
  end;
--
  function sha512( p_msg raw, p_512 boolean )
  return raw
  is
    t_md varchar2(128);
    fmt1 varchar2(20) := 'xxxxxxxxxxxxxxxx';
    fmt2 varchar2(20) := 'fm0xxxxxxxxxxxxxxx';
    t_len pls_integer;
    t_pad_len pls_integer;
    t_pad varchar2(288);
    t_msg_buf varchar2(32766);
    t_idx pls_integer;
    t_chunksize	pls_integer := 16256; -- 127 * 128
    t_block varchar2(256);
    type tp_tab	is table of number;
    Ht tp_tab;
    K tp_tab;
    w tp_tab;
    H_str varchar2(128);
    K_str varchar2(1280);
    a number;
    b number;
    c number;
    d number;
    e number;
    f number;
    g number;
    h number;
    s0 number;
    s1 number;
    maj	number;
    ch number;
    t1 number;
    t2 number;
    tmp	number;
  begin
    t_len := nvl( utl_raw.length( p_msg	), 0 );
    t_pad_len := 128 - mod( t_len, 128 );
    if t_pad_len < 17
    then
      t_pad_len	:= 128 + t_pad_len;
    end	if;
    t_pad := rpad( '8',	t_pad_len * 2 -	16, '0'	) || to_char( t_len * 8, 'fm0XXXXXXX' );
--
    if p_512
    then
      H_str := '6a09e667f3bcc908bb67ae8584caa73b3c6ef372fe94f82ba54ff53a5f1d36f1'
	    || '510e527fade682d19b05688c2b3e6c1f1f83d9abfb41bd6b5be0cd19137e2179';
    else
      H_str := 'cbbb9d5dc1059ed8629a292a367cd5079159015a3070dd17152fecd8f70e5939'
	    || '67332667ffc00b318eb44a8768581511db0c2e0d64f98fa747b5481dbefa4fa4';
    end	if;
    Ht := tp_tab();
    Ht.extend(8);
    for	i in 1 .. 8
    loop
      Ht(i) := to_number( substr( H_str, i * 16	- 15, 16 ), fmt1 );
    end	loop;
--
    K_str := '428a2f98d728ae227137449123ef65cdb5c0fbcfec4d3b2fe9b5dba58189dbbc'
	  || '3956c25bf348b53859f111f1b605d019923f82a4af194f9bab1c5ed5da6d8118'
	  || 'd807aa98a303024212835b0145706fbe243185be4ee4b28c550c7dc3d5ffb4e2'
	  || '72be5d74f27b896f80deb1fe3b1696b19bdc06a725c71235c19bf174cf692694'
	  || 'e49b69c19ef14ad2efbe4786384f25e30fc19dc68b8cd5b5240ca1cc77ac9c65'
	  || '2de92c6f592b02754a7484aa6ea6e4835cb0a9dcbd41fbd476f988da831153b5'
	  || '983e5152ee66dfaba831c66d2db43210b00327c898fb213fbf597fc7beef0ee4'
	  || 'c6e00bf33da88fc2d5a79147930aa72506ca6351e003826f142929670a0e6e70'
	  || '27b70a8546d22ffc2e1b21385c26c9264d2c6dfc5ac42aed53380d139d95b3df'
	  || '650a73548baf63de766a0abb3c77b2a881c2c92e47edaee692722c851482353b'
	  || 'a2bfe8a14cf10364a81a664bbc423001c24b8b70d0f89791c76c51a30654be30'
	  || 'd192e819d6ef5218d69906245565a910f40e35855771202a106aa07032bbd1b8'
	  || '19a4c116b8d2d0c81e376c085141ab532748774cdf8eeb9934b0bcb5e19b48a8'
	  || '391c0cb3c5c95a634ed8aa4ae3418acb5b9cca4f7763e373682e6ff3d6b2b8a3'
	  || '748f82ee5defb2fc78a5636f43172f6084c87814a1f0ab728cc702081a6439ec'
	  || '90befffa23631e28a4506cebde82bde9bef9a3f7b2c67915c67178f2e372532b'
	  || 'ca273eceea26619cd186b8c721c0c207eada7dd6cde0eb1ef57d4f7fee6ed178'
	  || '06f067aa72176fba0a637dc5a2c898a6113f9804bef90dae1b710b35131c471b'
	  || '28db77f523047d8432caab7b40c724933c9ebe0a15c9bebc431d67c49c100d4c'
	  || '4cc5d4becb3e42b6597f299cfc657e2a5fcb6fab3ad6faec6c44198c4a475817';
    K := tp_tab();
    K.extend(80);
    for	i in 1 .. 80
    loop
      K(i) := to_number( substr( K_str,	i * 16 - 15, 16	), fmt1	);
    end	loop;
--
    t_idx := 1;
    while t_idx	<= t_len + t_pad_len
    loop
      if t_len - t_idx + 1 >= t_chunksize
      then
	t_msg_buf := utl_raw.substr( p_msg, t_idx, t_chunksize );
	t_idx := t_idx + t_chunksize;
      else
	if t_idx <= t_len
	then
	  t_msg_buf := utl_raw.substr( p_msg, t_idx );
	  t_idx	:= t_len + 1;
	else
	  t_msg_buf := '';
	end if;
	if nvl(	length(	t_msg_buf ), 0 ) + t_pad_len * 2 <= 32766
	then
	  t_msg_buf := t_msg_buf || t_pad;
	  t_idx	:= t_idx + t_pad_len;
	end if;
      end if;
--
      for i in 1 .. length( t_msg_buf )	/ 256
      loop
--
	a := Ht(1);
	b := Ht(2);
	c := Ht(3);
	d := Ht(4);
	e := Ht(5);
	f := Ht(6);
	g := Ht(7);
	h := Ht(8);
--
	t_block	:= substr( t_msg_buf, i	* 256 -	255, 256 );
	w := tp_tab();
	w.extend( 80 );
	for j in 1 .. 16
	loop
	  w(j) := to_number( substr( t_block, j	* 16  -	15, 16 ), fmt1 );
	end loop;
--
	for j in 17 .. 80
	loop
	  tmp := w(j-15);
	  s0 :=	bitxor(	bitxor(	ror64( tmp, 1),	ror64( tmp, 8 )	), shr(	tmp, 7 ) );
	  tmp := w(j-2);
	  s1 :=	bitxor(	bitxor(	ror64( tmp, 19), ror64(	tmp, 61	) ), shr( tmp, 6 ) );
	  w(j) := bitand( w(j-16) + s0 + w(j-7)	+ s1, bmax64 );
	end loop;
--
	for j in 1 .. 80
	loop
	  s0 :=	bitxor(	bitxor(	ror64( a, 28 ),	ror64( a, 34 ) ), ror64( a, 39 ) );
	  maj := bitxor( bitxor( bitand( a, b ), bitand( a, c )	), bitand( b, c	) );
	  t2 :=	bitand(	s0 + maj, bmax64 );
	  s1 :=	bitxor(	bitxor(	ror64( e, 14 ),	ror64( e, 18 ) ), ror64( e, 41 ) );
	  ch :=	bitxor(	bitand(	e, f ),	bitand(	- e - 1, g ) );
	  t1 :=	h + s1 + ch + K(j) + w(j);
	  h := g;
	  g := f;
	  f := e;
	  e := d + t1;
	  d := c;
	  c := b;
	  b := a;
	  a := t1 + t2;
	end loop;
--
	Ht(1) := bitand( Ht(1) + a, bmax64 );
	Ht(2) := bitand( Ht(2) + b, bmax64 );
	Ht(3) := bitand( Ht(3) + c, bmax64 );
	Ht(4) := bitand( Ht(4) + d, bmax64 );
	Ht(5) := bitand( Ht(5) + e, bmax64 );
	Ht(6) := bitand( Ht(6) + f, bmax64 );
	Ht(7) := bitand( Ht(7) + g, bmax64 );
	Ht(8) := bitand( Ht(8) + h, bmax64 );
--
      end loop;
    end	loop;
    for	i in 1 .. case when p_512 then 8 else 6	end
    loop
      t_md := t_md || to_char( Ht(i), fmt2 );
    end	loop;
    return t_md;
  end;
--
  function hash( src raw, typ pls_integer )
  return raw
  is
  begin
    return case	typ
	     when HASH_MD4 then	md4( src )
	     when HASH_MD5 then	md5( src )
	     when HASH_SH1 then	sha1( src )
	     when HASH_SH224 then sha256( src, false )
	     when HASH_SH256 then sha256( src, true )
	     when HASH_SH384 then sha512( src, false )
	     when HASH_SH512 then sha512( src, true )
	     when HASH_RIPEMD160 then ripemd160( src )
	   end;
  end;
--
  function mac(	src raw, typ pls_integer, key raw )
  return raw
  is
    t_key raw(128);
    t_len pls_integer;
    t_blocksize	pls_integer := case
				 when typ in ( HMAC_SH384, HMAC_SH512 )
				   then	128
				   else	64
			       end;
    t_typ pls_integer := case typ
			   when	HMAC_MD4       then HASH_MD4
			   when	HMAC_MD5       then HASH_MD5
			   when	HMAC_SH1       then HASH_SH1
			   when	HMAC_SH224     then HASH_SH224
			   when	HMAC_SH256     then HASH_SH256
			   when	HMAC_SH384     then HASH_SH384
			   when	HMAC_SH512     then HASH_SH512
			   when	HMAC_RIPEMD160 then HASH_RIPEMD160
			 end;
  begin
    t_len := utl_raw.length( key );
    if t_len > t_blocksize
    then
      t_key := hash( key, t_typ	);
      t_len := utl_raw.length( t_key );
    else
      t_key := key;
    end	if;
    if t_len < t_blocksize
    then
      t_key := utl_raw.concat( t_key, utl_raw.copies( hextoraw(	'00' ),	t_blocksize - t_len ) );
    elsif t_len	is null
    then
      t_key := utl_raw.copies( hextoraw( '00' ), t_blocksize );
    end	if;
    return hash( utl_raw.concat( utl_raw.bit_xor( utl_raw.copies( hextoraw( '5c' ), t_blocksize	), t_key )
			       , hash( utl_raw.concat( utl_raw.bit_xor(	utl_raw.copies(	hextoraw( '36' ), t_blocksize ), t_key )
						     , src
						     )
				     , t_typ
				     )
			       )
	       , t_typ
	       );
  end;
--
  function randombytes(	number_bytes positive )
  return raw
  is
    type tp_arcfour_sbox is table of pls_integer index by pls_integer;
    type tp_arcfour is record
      (	s tp_arcfour_sbox
      ,	i pls_integer
      ,	j pls_integer
      );
    t_tmp pls_integer;
    t_s2 tp_arcfour_sbox;
    t_arcfour tp_arcfour;
    t_rv varchar2(32767);
    t_seed varchar2(3999);
  begin
    t_seed := utl_raw.cast_from_number(	dbms_utility.get_cpu_time )
	   || utl_raw.cast_from_number(	extract( second	from systimestamp ) )
	   || utl_raw.cast_from_number(	dbms_utility.get_time );
    for	i in 0 .. 255
    loop
      t_arcfour.s(i) :=	i;
    end	loop;
    t_seed := t_seed
	   || utl_raw.cast_from_number(	dbms_utility.get_time )
	   || utl_raw.cast_from_number(	extract( second	from systimestamp ) )
	   || utl_raw.cast_from_number(	dbms_utility.get_cpu_time );
    for	i in 0 .. 255
    loop
      t_s2(i) := to_number( substr( t_seed, mod( i, length( t_seed ) ) + 1, 1 ), 'XX' );
    end	loop;
    t_arcfour.j	:= 0;
    for	i in 0 .. 255
    loop
      t_arcfour.j := mod( t_arcfour.j +	t_arcfour.s(i) + t_s2(i), 256 );
      t_tmp := t_arcfour.s(i);
      t_arcfour.s(i) :=	t_arcfour.s( t_arcfour.j );
      t_arcfour.s( t_arcfour.j ) := t_tmp;
    end	loop;
    t_arcfour.i	:= 0;
    t_arcfour.j	:= 0;
--
    for	i in 1 .. 1536
    loop
      t_arcfour.i := bitand( t_arcfour.i + 1, 255 );
      t_arcfour.j := bitand( t_arcfour.j + t_arcfour.s(	t_arcfour.i ), 255 );
      t_tmp := t_arcfour.s( t_arcfour.i	);
      t_arcfour.s( t_arcfour.i ) := t_arcfour.s( t_arcfour.j );
      t_arcfour.s( t_arcfour.j ) := t_tmp;
    end	loop;
--
    for	i in 1 .. number_bytes
    loop
      t_arcfour.i := bitand( t_arcfour.i + 1, 255 );
      t_arcfour.j := bitand( t_arcfour.j + t_arcfour.s(	t_arcfour.i ), 255 );
      t_tmp := t_arcfour.s( t_arcfour.i	);
      t_arcfour.s( t_arcfour.i ) := t_arcfour.s( t_arcfour.j );
      t_arcfour.s( t_arcfour.j ) := t_tmp;
      t_rv := t_rv || to_char( t_arcfour.s( bitand( t_arcfour.s( t_arcfour.i ) + t_arcfour.s( t_arcfour.j ), 255 ) ), 'fm0x' );
    end	loop;
    return t_rv;
  end;
--
begin
  t_key	:= utl_i18n.string_to_raw( 'key', 'AL32UTF8' );
  t_src	:= utl_i18n.string_to_raw( 'The	quick brown fox	jumps over the lazy dog', 'AL32UTF8' );
--  t_key := '';
--  t_src := '';
  t_type := HMAC_MD5;
  t_mac	:= mac(	t_src, t_type, t_key );
  dbms_output.put_line(	t_mac );
  t_type := HMAC_SH1;
  t_mac	:= mac(	t_src, t_type, t_key );
  dbms_output.put_line(	t_mac );
  t_type := HMAC_SH256;
  t_mac	:= mac(	t_src, t_type, t_key );
  dbms_output.put_line(	t_mac );
end;


declare
-- blowfish
ts timestamp;
bb boolean := false;
  p_key	raw(512);
  t_key_idx pls_integer;
  t_build raw(4);
  t_zero raw(8);
  type tp_p_tab	is table of raw(4);
  p_box	tp_p_tab;
  tmp_box tp_p_tab;
  type tp_s_tab	is table of number index by pls_integer;
  s_box0 tp_s_tab;
  s_box1 tp_s_tab;
  s_box2 tp_s_tab;
  s_box3 tp_s_tab;
--
  function f( x	raw )
  return raw
  is
    h raw(4);
  begin
--c_ffffffff number := to_number( 'ffffffff', 'xxxxxxxx' );
--xor(x,y) = bitand( c_ffffffff, x + y - 2 * bitand( x,	y ) );
    h := substr( to_char( s_box0( to_number( utl_raw.substr( x,	1, 1 ),	'xx' ) )
			+ s_box1( to_number( utl_raw.substr( x,	2, 1 ),	'xx' ) )
			, 'fm0XXXXXXXXX'
			), -8 );
    return substr( to_char( to_number( utl_raw.bit_xor(	h
						      ,	to_char( s_box2( to_number( utl_raw.substr( x, 3, 1 ), 'xx' ) ), 'fm0XXXXXXX' )
						      )
				     , 'XXXXXXXX'
				     )
			  + s_box3( to_number( utl_raw.substr( x, 4, 1 ), 'xx' ) )
			  , 'fm0XXXXXXXXX'
			  ), -8	);
  end;
--
  function encryptBlock( p_plain raw )
  return raw
  is
    nHi	raw(4) := utl_raw.substr( p_plain, 1, 4	);
    nLo	raw(4) := utl_raw.substr( p_plain, 5, 4	);
    h raw(4);
  begin
    nHi	:= utl_raw.bit_xor( nHi, p_box(1) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(2) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(3) ) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(4) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(5) ) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(6) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(7) ) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(8) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(9) ) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(10) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(11) )	);
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(12) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(13) )	);
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(14) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(15) )	);
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(16) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(17) )	);
    return utl_raw.concat( utl_raw.bit_xor( nLo, p_box(18) ), nHi );
  end;
--
  function decryptBlock( p_cypher raw )
  return raw
  is
    nHi	raw(4) := utl_raw.substr( p_cypher, 1, 4 );
    nLo	raw(4) := utl_raw.substr( p_cypher, 5, 4 );
  begin
    nHi	:= utl_raw.bit_xor( nHi, p_box(18) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(17) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(16) )	);
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(15) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(14) )	);
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(13) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(12) )	);
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(11) )	);
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(10) )	);
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(9) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(8) ) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(7) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(6) ) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(5) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(4) ) );
    nLo	:= utl_raw.bit_xor( nLo, utl_raw.bit_xor( f( nHi ), p_box(3) ) );
    nHi	:= utl_raw.bit_xor( nhI, utl_raw.bit_xor( f( nLo ), p_box(2) ) );
    return utl_raw.concat( utl_raw.bit_xor( nLo, p_box(1) ), nHi );
  end;
begin
  p_box	:= tp_p_tab( '243f6a88', '85a308d3', '13198a2e', '03707344', 'a4093822'
		   , '299f31d0', '082efa98', 'ec4e6c89', '452821e6', '38d01377'
		   , 'be5466cf', '34e90c6c', 'c0ac29b7', 'c97c50dd', '3f84d5b5'
		   , 'b5470917', '9216d5d9', '8979fb1b'
		   );
tmp_box	:= tp_p_tab( 'd1310ba6',   '98dfb5ac',	 '2ffd72db',   'd01adfb7',   'b8e1afed',   '6a267e96',
	    'ba7c9045',	  'f12c7f99',	'24a19947',   'b3916cf7',   '0801f2e2',	  '858efc16',
	    '636920d8',	  '71574e69',	'a458fea3',   'f4933d7e',   '0d95748f',	  '728eb658',
	    '718bcd58',	  '82154aee',	'7b54a41d',   'c25a59b5',   '9c30d539',	  '2af26013',
	    'c5d1b023',	  '286085f0',	'ca417918',   'b8db38ef',   '8e79dcb0',	  '603a180e',
	    '6c9e0e8b',	  'b01e8a3e',	'd71577c1',   'bd314b27',   '78af2fda',	  '55605c60',
	    'e65525f3',	  'aa55ab94',	'57489862',   '63e81440',   '55ca396a',	  '2aab10b6',
	    'b4cc5c34',	  '1141e8ce',	'a15486af',   '7c72e993',   'b3ee1411',	  '636fbc2a',
	    '2ba9c55d',	  '741831f6',	'ce5c3e16',   '9b87931e',   'afd6ba33',	  '6c24cf5c',
	    '7a325381',	  '28958677',	'3b8f4898',   '6b4bb9af',   'c4bfe81b',	  '66282193',
	    '61d809cc',	  'fb21a991',	'487cac60',   '5dec8032',   'ef845d5d',	  'e98575b1',
	    'dc262302',	  'eb651b88',	'23893e81',   'd396acc5',   '0f6d6ff3',	  '83f44239',
	    '2e0b4482',	  'a4842004',	'69c8f04a',   '9e1f9b5e',   '21c66842',	  'f6e96c9a',
	    '670c9c61',	  'abd388f0',	'6a51a0d2',   'd8542f68',   '960fa728',	  'ab5133a3',
	    '6eef0b6c',	  '137a3be4',	'ba3bf050',   '7efb2a98',   'a1f1651d',	  '39af0176',
	    '66ca593e',	  '82430e88',	'8cee8619',   '456f9fb4',   '7d84a5c3',	  '3b8b5ebe',
	    'e06f75d8',	  '85c12073',	'401a449f',   '56c16aa6',   '4ed3aa62',	  '363f7706',
	    '1bfedf72',	  '429b023d',	'37d0d724',   'd00a1248',   'db0fead3',	  '49f1c09b',
	    '075372c9',	  '80991b7b',	'25d479d8',   'f6e8def7',   'e3fe501a',	  'b6794c3b',
	    '976ce0bd',	  '04c006ba',	'c1a94fb6',   '409f60c4',   '5e5c9ec2',	  '196a2463',
	    '68fb6faf',	  '3e6c53b5',	'1339b2eb',   '3b52ec6f',   '6dfc511f',	  '9b30952c',
	    'cc814544',	  'af5ebd09',	'bee3d004',   'de334afd',   '660f2807',	  '192e4bb3',
	    'c0cba857',	  '45c8740f',	'd20b5f39',   'b9d3fbdb',   '5579c0bd',	  '1a60320a',
	    'd6a100c6',	  '402c7279',	'679f25fe',   'fb1fa3cc',   '8ea5e9f8',	  'db3222f8',
	    '3c7516df',	  'fd616b15',	'2f501ec8',   'ad0552ab',   '323db5fa',	  'fd238760',
	    '53317b48',	  '3e00df82',	'9e5c57bb',   'ca6f8ca0',   '1a87562e',	  'df1769db',
	    'd542a8f6',	  '287effc3',	'ac6732c6',   '8c4f5573',   '695b27b0',	  'bbca58c8',
	    'e1ffa35d',	  'b8f011a0',	'10fa3d98',   'fd2183b8',   '4afcb56c',	  '2dd1d35b',
	    '9a53e479',	  'b6f84565',	'd28e49bc',   '4bfb9790',   'e1ddf2da',	  'a4cb7e33',
	    '62fb1341',	  'cee4c6e8',	'ef20cada',   '36774c01',   'd07e9efe',	  '2bf11fb4',
	    '95dbda4d',	  'ae909198',	'eaad8e71',   '6b93d5a0',   'd08ed1d0',	  'afc725e0',
	    '8e3c5b2f',	  '8e7594b7',	'8ff6e2fb',   'f2122b64',   '8888b812',	  '900df01c',
	    '4fad5ea0',	  '688fc31c',	'd1cff191',   'b3a8c1ad',   '2f2f2218',	  'be0e1777',
	    'ea752dfe',	  '8b021fa1',	'e5a0cc0f',   'b56f74e8',   '18acf3d6',	  'ce89e299',
	    'b4a84fe0',	  'fd13e0b7',	'7cc43b81',   'd2ada8d9',   '165fa266',	  '80957705',
	    '93cc7314',	  '211a1477',	'e6ad2065',   '77b5fa86',   'c75442f5',	  'fb9d35cf',
	    'ebcdaf0c',	  '7b3e89a0',	'd6411bd3',   'ae1e7e49',   '00250e2d',	  '2071b35e',
	    '226800bb',	  '57b8e0af',	'2464369b',   'f009b91e',   '5563911d',	  '59dfa6aa',
	    '78c14389',	  'd95a537f',	'207d5ba2',   '02e5b9c5',   '83260376',	  '6295cfa9',
	    '11c81968',	  '4e734a41',	'b3472dca',   '7b14a94a',   '1b510052',	  '9a532915',
	    'd60f573f',	  'bc9bc6e4',	'2b60a476',   '81e67400',   '08ba6fb5',	  '571be91f',
	    'f296ec6b',	  '2a0dd915',	'b6636521',   'e7b9f9b6',   'ff34052e',	  'c5855664',
	    '53b02d5d',	  'a99f8fa1',	'08ba4799',   '6e85076a' );
  for i	in 0 ..	255
  loop
    s_box0( i )	:= to_number( tmp_box( i + 1 ),	'xxxxxxxx' );
  end loop;
--
tmp_box	:= tp_p_tab(		 '4b7a70e9',   'b5b32944',
	    'db75092e',	  'c4192623',	'ad6ea6b0',   '49a7df7d',   '9cee60b8',	  '8fedb266',
	    'ecaa8c71',	  '699a17ff',	'5664526c',   'c2b19ee1',   '193602a5',	  '75094c29',
	    'a0591340',	  'e4183a3e',	'3f54989a',   '5b429d65',   '6b8fe4d6',	  '99f73fd6',
	    'a1d29c07',	  'efe830f5',	'4d2d38e6',   'f0255dc1',   '4cdd2086',	  '8470eb26',
	    '6382e9c6',	  '021ecc5e',	'09686b3f',   '3ebaefc9',   '3c971814',	  '6b6a70a1',
	    '687f3584',	  '52a0e286',	'b79c5305',   'aa500737',   '3e07841c',	  '7fdeae5c',
	    '8e7d44ec',	  '5716f2b8',	'b03ada37',   'f0500c0d',   'f01c1f04',	  '0200b3ff',
	    'ae0cf51a',	  '3cb574b2',	'25837a58',   'dc0921bd',   'd19113f9',	  '7ca92ff6',
	    '94324773',	  '22f54701',	'3ae5e581',   '37c2dadc',   'c8b57634',	  '9af3dda7',
	    'a9446146',	  '0fd0030e',	'ecc8c73e',   'a4751e41',   'e238cd99',	  '3bea0e2f',
	    '3280bba1',	  '183eb331',	'4e548b38',   '4f6db908',   '6f420d03',	  'f60a04bf',
	    '2cb81290',	  '24977c79',	'5679b072',   'bcaf89af',   'de9a771f',	  'd9930810',
	    'b38bae12',	  'dccf3f2e',	'5512721f',   '2e6b7124',   '501adde6',	  '9f84cd87',
	    '7a584718',	  '7408da17',	'bc9f9abc',   'e94b7d8c',   'ec7aec3a',	  'db851dfa',
	    '63094366',	  'c464c3d2',	'ef1c1847',   '3215d908',   'dd433b37',	  '24c2ba16',
	    '12a14d43',	  '2a65c451',	'50940002',   '133ae4dd',   '71dff89e',	  '10314e55',
	    '81ac77d6',	  '5f11199b',	'043556f1',   'd7a3c76b',   '3c11183b',	  '5924a509',
	    'f28fe6ed',	  '97f1fbfa',	'9ebabf2c',   '1e153c6e',   '86e34570',	  'eae96fb1',
	    '860e5e0a',	  '5a3e2ab3',	'771fe71c',   '4e3d06fa',   '2965dcb9',	  '99e71d0f',
	    '803e89d6',	  '5266c825',	'2e4cc978',   '9c10b36a',   'c6150eba',	  '94e2ea78',
	    'a5fc3c53',	  '1e0a2df4',	'f2f74ea7',   '361d2b3d',   '1939260f',	  '19c27960',
	    '5223a708',	  'f71312b6',	'ebadfe6e',   'eac31f66',   'e3bc4595',	  'a67bc883',
	    'b17f37d1',	  '018cff28',	'c332ddef',   'be6c5aa5',   '65582185',	  '68ab9802',
	    'eecea50f',	  'db2f953b',	'2aef7dad',   '5b6e2f84',   '1521b628',	  '29076170',
	    'ecdd4775',	  '619f1510',	'13cca830',   'eb61bd96',   '0334fe1e',	  'aa0363cf',
	    'b5735c90',	  '4c70a239',	'd59e9e0b',   'cbaade14',   'eecc86bc',	  '60622ca7',
	    '9cab5cab',	  'b2f3846e',	'648b1eaf',   '19bdf0ca',   'a02369b9',	  '655abb50',
	    '40685a32',	  '3c2ab4b3',	'319ee9d5',   'c021b8f7',   '9b540b19',	  '875fa099',
	    '95f7997e',	  '623d7da8',	'f837889a',   '97e32d77',   '11ed935f',	  '16681281',
	    '0e358829',	  'c7e61fd6',	'96dedfa1',   '7858ba99',   '57f584a5',	  '1b227263',
	    '9b83c3ff',	  '1ac24696',	'cdb30aeb',   '532e3054',   '8fd948e4',	  '6dbc3128',
	    '58ebf2ef',	  '34c6ffea',	'fe28ed61',   'ee7c3c73',   '5d4a14d9',	  'e864b7e3',
	    '42105d14',	  '203e13e0',	'45eee2b6',   'a3aaabea',   'db6c4f15',	  'facb4fd0',
	    'c742f442',	  'ef6abbb5',	'654f3b1d',   '41cd2105',   'd81e799e',	  '86854dc7',
	    'e44b476a',	  '3d816250',	'cf62a1f2',   '5b8d2646',   'fc8883a0',	  'c1c7b6a3',
	    '7f1524c3',	  '69cb7492',	'47848a0b',   '5692b285',   '095bbf00',	  'ad19489d',
	    '1462b174',	  '23820e00',	'58428d2a',   '0c55f5ea',   '1dadf43e',	  '233f7061',
	    '3372f092',	  '8d937e41',	'd65fecf1',   '6c223bdb',   '7cde3759',	  'cbee7460',
	    '4085f2a7',	  'ce77326e',	'a6078084',   '19f8509e',   'e8efd855',	  '61d99735',
	    'a969a7aa',	  'c50c06c2',	'5a04abfc',   '800bcadc',   '9e447a2e',	  'c3453484',
	    'fdd56705',	  '0e1e9ec9',	'db73dbd3',   '105588cd',   '675fda79',	  'e3674340',
	    'c5c43465',	  '713e38d8',	'3d28f89e',   'f16dff20',   '153e21e7',	  '8fb03d4a',
	    'e6e39f2b',	  'db83adf7' );
  for i	in 0 ..	255
  loop
    s_box1( i )	:= to_number( tmp_box( i + 1 ),	'xxxxxxxx' );
  end loop;
--
tmp_box	:= tp_p_tab( 'e93d5a68',   '948140f7',	 'f64c261c',   '94692934',
	    '411520f7',	  '7602d4f7',	'bcf46b2e',   'd4a20068',   'd4082471',	  '3320f46a',
	    '43b7d4b7',	  '500061af',	'1e39f62e',   '97244546',   '14214f74',	  'bf8b8840',
	    '4d95fc1d',	  '96b591af',	'70f4ddd3',   '66a02f45',   'bfbc09ec',	  '03bd9785',
	    '7fac6dd0',	  '31cb8504',	'96eb27b3',   '55fd3941',   'da2547e6',	  'abca0a9a',
	    '28507825',	  '530429f4',	'0a2c86da',   'e9b66dfb',   '68dc1462',	  'd7486900',
	    '680ec0a4',	  '27a18dee',	'4f3ffea2',   'e887ad8c',   'b58ce006',	  '7af4d6b6',
	    'aace1e7c',	  'd3375fec',	'ce78a399',   '406b2a42',   '20fe9e35',	  'd9f385b9',
	    'ee39d7ab',	  '3b124e8b',	'1dc9faf7',   '4b6d1856',   '26a36631',	  'eae397b2',
	    '3a6efa74',	  'dd5b4332',	'6841e7f7',   'ca7820fb',   'fb0af54e',	  'd8feb397',
	    '454056ac',	  'ba489527',	'55533a3a',   '20838d87',   'fe6ba9b7',	  'd096954b',
	    '55a867bc',	  'a1159a58',	'cca92963',   '99e1db33',   'a62a4a56',	  '3f3125f9',
	    '5ef47e1c',	  '9029317c',	'fdf8e802',   '04272f70',   '80bb155c',	  '05282ce3',
	    '95c11548',	  'e4c66d22',	'48c1133f',   'c70f86dc',   '07f9c9ee',	  '41041f0f',
	    '404779a4',	  '5d886e17',	'325f51eb',   'd59bc0d1',   'f2bcc18f',	  '41113564',
	    '257b7834',	  '602a9c60',	'dff8e8a3',   '1f636c1b',   '0e12b4c2',	  '02e1329e',
	    'af664fd1',	  'cad18115',	'6b2395e0',   '333e92e1',   '3b240b62',	  'eebeb922',
	    '85b2a20e',	  'e6ba0d99',	'de720c8c',   '2da2f728',   'd0127845',	  '95b794fd',
	    '647d0862',	  'e7ccf5f0',	'5449a36f',   '877d48fa',   'c39dfd27',	  'f33e8d1e',
	    '0a476341',	  '992eff74',	'3a6f6eab',   'f4f8fd37',   'a812dc60',	  'a1ebddf8',
	    '991be14c',	  'db6e6b0d',	'c67b5510',   '6d672c37',   '2765d43b',	  'dcd0e804',
	    'f1290dc7',	  'cc00ffa3',	'b5390f92',   '690fed0b',   '667b9ffb',	  'cedb7d9c',
	    'a091cf0b',	  'd9155ea3',	'bb132f88',   '515bad24',   '7b9479bf',	  '763bd6eb',
	    '37392eb3',	  'cc115979',	'8026e297',   'f42e312d',   '6842ada7',	  'c66a2b3b',
	    '12754ccc',	  '782ef11c',	'6a124237',   'b79251e7',   '06a1bbe6',	  '4bfb6350',
	    '1a6b1018',	  '11caedfa',	'3d25bdd8',   'e2e1c3c9',   '44421659',	  '0a121386',
	    'd90cec6e',	  'd5abea2a',	'64af674e',   'da86a85f',   'bebfe988',	  '64e4c3fe',
	    '9dbc8057',	  'f0f7c086',	'60787bf8',   '6003604d',   'd1fd8346',	  'f6381fb0',
	    '7745ae04',	  'd736fccc',	'83426b33',   'f01eab71',   'b0804187',	  '3c005e5f',
	    '77a057be',	  'bde8ae24',	'55464299',   'bf582e61',   '4e58f48f',	  'f2ddfda2',
	    'f474ef38',	  '8789bdc2',	'5366f9c3',   'c8b38e74',   'b475f255',	  '46fcd9b9',
	    '7aeb2661',	  '8b1ddf84',	'846a0e79',   '915f95e2',   '466e598e',	  '20b45770',
	    '8cd55591',	  'c902de4c',	'b90bace1',   'bb8205d0',   '11a86248',	  '7574a99e',
	    'b77f19b6',	  'e0a9dc09',	'662d09a1',   'c4324633',   'e85a1f02',	  '09f0be8c',
	    '4a99a025',	  '1d6efe10',	'1ab93d1d',   '0ba5a4df',   'a186f20f',	  '2868f169',
	    'dcb7da83',	  '573906fe',	'a1e2ce9b',   '4fcd7f52',   '50115e01',	  'a70683fa',
	    'a002b5c4',	  '0de6d027',	'9af88c27',   '773f8641',   'c3604c06',	  '61a806b5',
	    'f0177a28',	  'c0f586e0',	'006058aa',   '30dc7d62',   '11e69ed7',	  '2338ea63',
	    '53c2dd94',	  'c2c21634',	'bbcbee56',   '90bcb6de',   'ebfc7da1',	  'ce591d76',
	    '6f05e409',	  '4b7c0188',	'39720a3d',   '7c927c24',   '86e3725f',	  '724d9db9',
	    '1ac15bb4',	  'd39eb8fc',	'ed545578',   '08fca5b5',   'd83d7cd3',	  '4dad0fc4',
	    '1e50ef5e',	  'b161e6f8',	'a28514d9',   '6c51133c',   '6fd5c7e7',	  '56e14ec4',
	    '362abfce',	  'ddc6c837',	'd79a3234',   '92638212',   '670efa8e',	  '406000e0' );
  for i	in 0 ..	255
  loop
    s_box2( i )	:= to_number( tmp_box( i + 1 ),	'xxxxxxxx' );
  end loop;
--
tmp_box	:= tp_p_tab( '3a39ce37',   'd3faf5cf',	 'abc27737',   '5ac52d1b',   '5cb0679e',   '4fa33742',
	    'd3822740',	  '99bc9bbe',	'd5118e9d',   'bf0f7315',   'd62d1c7e',	  'c700c47b',
	    'b78c1b6b',	  '21a19045',	'b26eb1be',   '6a366eb4',   '5748ab2f',	  'bc946e79',
	    'c6a376d2',	  '6549c2c8',	'530ff8ee',   '468dde7d',   'd5730a1d',	  '4cd04dc6',
	    '2939bbdb',	  'a9ba4650',	'ac9526e8',   'be5ee304',   'a1fad5f0',	  '6a2d519a',
	    '63ef8ce2',	  '9a86ee22',	'c089c2b8',   '43242ef6',   'a51e03aa',	  '9cf2d0a4',
	    '83c061ba',	  '9be96a4d',	'8fe51550',   'ba645bd6',   '2826a2f9',	  'a73a3ae1',
	    '4ba99586',	  'ef5562e9',	'c72fefd3',   'f752f7da',   '3f046f69',	  '77fa0a59',
	    '80e4a915',	  '87b08601',	'9b09e6ad',   '3b3ee593',   'e990fd5a',	  '9e34d797',
	    '2cf0b7d9',	  '022b8b51',	'96d5ac3a',   '017da67d',   'd1cf3ed6',	  '7c7d2d28',
	    '1f9f25cf',	  'adf2b89b',	'5ad6b472',   '5a88f54c',   'e029ac71',	  'e019a5e6',
	    '47b0acfd',	  'ed93fa9b',	'e8d3c48d',   '283b57cc',   'f8d56629',	  '79132e28',
	    '785f0191',	  'ed756055',	'f7960e44',   'e3d35e8c',   '15056dd4',	  '88f46dba',
	    '03a16125',	  '0564f0bd',	'c3eb9e15',   '3c9057a2',   '97271aec',	  'a93a072a',
	    '1b3f6d9b',	  '1e6321f5',	'f59c66fb',   '26dcf319',   '7533d928',	  'b155fdf5',
	    '03563482',	  '8aba3cbb',	'28517711',   'c20ad9f8',   'abcc5167',	  'ccad925f',
	    '4de81751',	  '3830dc8e',	'379d5862',   '9320f991',   'ea7a90c2',	  'fb3e7bce',
	    '5121ce64',	  '774fbe32',	'a8b6e37e',   'c3293d46',   '48de5369',	  '6413e680',
	    'a2ae0810',	  'dd6db224',	'69852dfd',   '09072166',   'b39a460a',	  '6445c0dd',
	    '586cdecf',	  '1c20c8ae',	'5bbef7dd',   '1b588d40',   'ccd2017f',	  '6bb4e3bb',
	    'dda26a7e',	  '3a59ff45',	'3e350a44',   'bcb4cdd5',   '72eacea8',	  'fa6484bb',
	    '8d6612ae',	  'bf3c6f47',	'd29be463',   '542f5d9e',   'aec2771b',	  'f64e6370',
	    '740e0d8d',	  'e75b1357',	'f8721671',   'af537d5d',   '4040cb08',	  '4eb4e2cc',
	    '34d2466a',	  '0115af84',	'e1b00428',   '95983a1d',   '06b89fb4',	  'ce6ea048',
	    '6f3f3b82',	  '3520ab82',	'011a1d4b',   '277227f8',   '611560b1',	  'e7933fdc',
	    'bb3a792b',	  '344525bd',	'a08839e1',   '51ce794b',   '2f32c9b7',	  'a01fbac9',
	    'e01cc87e',	  'bcc7d1f6',	'cf0111c3',   'a1e8aac7',   '1a908749',	  'd44fbd9a',
	    'd0dadecb',	  'd50ada38',	'0339c32a',   'c6913667',   '8df9317c',	  'e0b12b4f',
	    'f79e59b7',	  '43f5bb3a',	'f2d519ff',   '27d9459c',   'bf97222c',	  '15e6fc2a',
	    '0f91fc71',	  '9b941525',	'fae59361',   'ceb69ceb',   'c2a86459',	  '12baa8d1',
	    'b6c1075e',	  'e3056a0c',	'10d25065',   'cb03a442',   'e0ec6e0e',	  '1698db3b',
	    '4c98a0be',	  '3278e964',	'9f1f9532',   'e0d392df',   'd3a0342b',	  '8971f21e',
	    '1b0a7441',	  '4ba3348c',	'c5be7120',   'c37632d8',   'df359f8d',	  '9b992f2e',
	    'e60b6f47',	  '0fe3f11d',	'e54cda54',   '1edad891',   'ce6279cf',	  'cd3e7e6f',
	    '1618b166',	  'fd2c1d05',	'848fd2c5',   'f6fb2299',   'f523f357',	  'a6327623',
	    '93a83531',	  '56cccd02',	'acf08162',   '5a75ebb5',   '6e163697',	  '88d273cc',
	    'de966292',	  '81b949d0',	'4c50901b',   '71c65614',   'e6c6c7bd',	  '327a140a',
	    '45e1d006',	  'c3f27b9a',	'c9aa53fd',   '62a80f00',   'bb25bfe2',	  '35bdd2f6',
	    '71126905',	  'b2040222',	'b6cbcf7c',   'cd769c2b',   '53113ec0',	  '1640e3d3',
	    '38abbd60',	  '2547adf0',	'ba38209c',   'f746ce76',   '77afa1c5',	  '20756060',
	    '85cbfe4e',	  '8ae88dd8',	'7aaaf9b0',   '4cf9aa7e',   '1948c25c',	  '02fb8a8c',
	    '01c36ae4',	  'd6ebe1f9',	'90d4f869',   'a65cdea0',   '3f09252d',	  'c208e69f',
	    'b74e6132',	  'ce77e25b',	'578fdfe3',   '3ac372e6' );
  for i	in 0 ..	255
  loop
    s_box3( i )	:= to_number( tmp_box( i + 1 ),	'xxxxxxxx' );
  end loop;
--
ts := systimestamp;
  p_key	:= '7CA110454A1A6E57';
  t_key_idx := 1;
  t_build := '00000000';
  for i	in p_box.first .. p_box.last
  loop
    for	j in 0 .. 3
    loop
      t_build := utl_raw.bit_or( utl_raw.substr( t_build, 2 ), utl_raw.concat( '000000', utl_raw.substr( p_key,	t_key_idx, 1 ) ) );
      if t_key_idx < utl_raw.length( p_key )
      then
	t_key_idx := t_key_idx + 1;
      else
	t_key_idx := 1;
      end if;
    end	loop;
    p_box( i ) := utl_raw.bit_xor( p_box( i ), t_build );
  end loop;
  t_zero := '0000000000000000';
  for i	in 1 ..	9
  loop
    t_zero := encryptBlock( t_zero );
    p_box( i * 2 - 1 ) := utl_raw.substr( t_zero, 1, 4 );
    p_box( i * 2 ) := utl_raw.substr( t_zero, 5, 4 );
  end loop;
  for i	in 0 ..	127
  loop
    t_zero := encryptBlock( t_zero );
    s_box0( i *	2 ) := to_number( utl_raw.substr( t_zero, 1, 4 ), 'xxxxxxxx' );
    s_box0( i *	2 + 1 )	:= to_number( utl_raw.substr( t_zero, 5, 4 ), 'xxxxxxxx' );
  end loop;
  for i	in 0 ..	127
  loop
    t_zero := encryptBlock( t_zero );
    s_box1( i *	2 ) := to_number( utl_raw.substr( t_zero, 1, 4 ), 'xxxxxxxx' );
    s_box1( i *	2 + 1 )	:= to_number( utl_raw.substr( t_zero, 5, 4 ), 'xxxxxxxx' );
  end loop;
  for i	in 0 ..	127
  loop
    t_zero := encryptBlock( t_zero );
    s_box2( i *	2 ) := to_number( utl_raw.substr( t_zero, 1, 4 ), 'xxxxxxxx' );
    s_box2( i *	2 + 1 )	:= to_number( utl_raw.substr( t_zero, 5, 4 ), 'xxxxxxxx' );
  end loop;
  for i	in 0 ..	127
  loop
    t_zero := encryptBlock( t_zero );
    s_box3( i *	2 ) := to_number( utl_raw.substr( t_zero, 1, 4 ), 'xxxxxxxx' );
    s_box3( i *	2 + 1 )	:= to_number( utl_raw.substr( t_zero, 5, 4 ), 'xxxxxxxx' );
  end loop;
dbms_output.put_line( decryptBlock( encryptBlock( '01A1D6D039776742' ) ) );
dbms_output.put_line( systimestamp - ts	);
end;

declare
  type tp_tab is table of pls_integer index by pls_integer;
  Z tp_tab;
  x tp_tab;
  DK tp_tab;
  procedure idea_init( p_key raw )
  is
    j pls_integer;
    k pls_integer;
    t1 pls_integer;
    t2 pls_integer;
    t3 pls_integer;
    c_ffff pls_integer := to_number( 'ffff', 'xxxx' );
    c_10001 pls_integer	:= to_number( '10001', 'xxxxx' );
--
    function bor( x number, y number )
    return number
    is
    begin
      return bitand( x + y - bitand( x,	y ), c_ffff );
    end;
--
    function xor( x number, y number )
    return number
    is
    begin
      return bitand( x + y - 2 * bitand( x, y ), c_ffff	);
    end;
--
    function inv( px pls_integer )
    return pls_integer
    is
      t0 pls_integer;
      t1 pls_integer;
      q	pls_integer;
      x	pls_integer;
      y	pls_integer;
    begin
      if px <= 1
      then
	return px;
      end if;
      t1 := trunc( c_10001 / px	);
      y	:= mod(	c_10001, px );
      if y = 1
      then
	return bitand( 1 - t1, c_FFFF );
      end if;
      x	:= px;
      t0 := 1;
      loop
	q := trunc( x /	y );
	x := mod( x, y );
	t0 := t0 + q * t1;
	if x = 1
	then
	  return t0;
	end if;
	q := trunc( y /	x );
	y := mod( y, x );
	t1 := t1 + q * t0;
	exit when y = 1;
      end loop;
      return bitand( 1 - t1, c_FFFF );
    end;
--
  begin
    for	i in 0 .. 7
    loop
      Z(i) := to_number( utl_raw.substr( p_key,	i*2 + 1, 2 ), 'xxxx' );
    end	loop;
    for	i in 8 ..51
    loop
      if bitand( i, 7 )	< 6
      then
	Z(i) :=	bor( Z(i-7) * 512, trunc( Z(i-6) / 128 ) );
      elsif bitand( i, 7 ) = 6
      then
	Z(i) :=	bor( Z(i-7) * 512, trunc( Z(i-14) / 128	) );
      else
	Z(i) :=	bor( Z(i-15) * 512, trunc( Z(i-14) / 128 ) );
      end if;
    end	loop;
--
    if utl_raw.bit_or( p_key, '00000000010000000000000111111000' ) = '00000000010000000000000111111000'	and false
    then -- weak keys
dbms_output.put_line( 'weak' );
      for i in 0 ..51
      loop
	Z(i) :=	xor( Z(i), to_number( '0dae', 'xxxx' ) );
      end loop;
    end	if;
--
    t1 := inv( Z(0) );
    t2 := bitand( -Z(1), c_ffff	);
    t3 := bitand( -Z(2), c_ffff	);
    DK(51) := inv( Z(3)	);
    DK(50) := t3;
    DK(49) := t2;
    DK(48) := t1;
    j := 47;
    k := 4;
    for	i in 0 .. 6
    loop
      t1 := Z( k );
      k	:= k + 1;
      DK( j ) := Z( K );
      j	:= j - 1;
      k	:= k + 1;
      DK( j ) := t1;
      j	:= j - 1;
      t1 := inv( Z( k )	);
      k	:= k + 1;
      t2 := bitand( -Z(	k ), c_ffff );
      k	:= k + 1;
      t3 := bitand( -Z(	k ), c_ffff );
      k	:= k + 1;
      DK( j ) := inv( Z( K ) );
      j	:= j - 1;
      k	:= k + 1;
      DK( j ) := t2;
      j	:= j - 1;
      DK( j ) := t3;
      j	:= j - 1;
      DK( j ) := t1;
      j	:= j - 1;
    end	loop;
    t1 := Z( k );
    k := k + 1;
    DK(	j ) := Z( K );
    j := j - 1;
    k := k + 1;
    DK(	j ) := t1;
    j := j - 1;
    t1 := inv( Z( k ) );
    k := k + 1;
    t2 := bitand( -Z( k	), c_ffff );
    k := k + 1;
    t3 := bitand( -Z( k	), c_ffff );
    k := k + 1;
    DK(	j ) := inv( Z( K ) );
    j := j - 1;
    k := k + 1;
    DK(	j ) := t3;
    j := j - 1;
    DK(	j ) := t2;
    j := j - 1;
    DK(	j ) := t1;
    j := j - 1;
  end;
--
  function idea_block( p_block raw, p_key tp_tab )
  return raw
  is
    x1 number;
    x2 number;
    x3 number;
    x4 number;
    t1 number;
    t2 number;
    c_ffff number := to_number(	'ffff',	'xxxx' );
    c_10001 number := to_number( '10001', 'xxxxx' );
--
    function xor( x number, y number )
    return number
    is
    begin
      return bitand( x + y - 2 * bitand( x, y ), c_ffff	);
    end;
--
    function mul( a number, b number )
    return number
    is
      x	number;
      y	number;
    begin
      if a = 0
      then
	x := 65536;
      else
	x := a;
      end if;
      if b = 0
      then
	y := 65536;
      else
	y := b;
      end if;
      return bitand( mod( x * y, c_10001 ), c_ffff );
    end;
  begin
    x1 := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 1, 2	), utl_raw.big_endian );
    x2 := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 3, 2	), utl_raw.big_endian );
    x3 := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 5, 2	), utl_raw.big_endian );
    x4 := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 7, 2	), utl_raw.big_endian );
    for	i in 0 .. 7
    loop
      x1 := mul( x1, p_key( i *	6 + 0 )	);
      x2 := bitand( x2 + p_key(	i * 6 +	1 ), c_ffff );
      x3 := bitand( x3 + p_key(	i * 6 +	2 ), c_ffff );
      x4 := mul( x4, p_key( i *	6 + 3 )	);
      t2 := xor( x1, x3	);
      t2 := mul( t2, p_key( i *	6 + 4 )	);
      t1 := bitand( t2 + xor( x2, x4 ),	c_ffff );
      t1 := mul( t1, p_key( i *	6 + 5 )	);
      t2 := bitand( t1 + t2, c_ffff );
      x1 := xor( x1, t1	);
      x4 := xor( x4, t2	);
      t2 := xor( t2, x2	);
      x2 := xor( x3, t1	);
      x3 := t2;
    end	loop;
    x1 := mul( x1, p_key( 48 ) );
    x3 := bitand( x3 +	p_key( 49 ), c_ffff );
    x2 := bitand( x2 +	p_key( 50 ), c_ffff );
    x4 := mul( x4, p_key( 51 ) );
    return utl_raw.concat( to_char( x1,	'fm0XXX' )
			 , to_char( x3,	'fm0XXX' )
			 , to_char( x2,	'fm0XXX' )
			 , to_char( x4,	'fm0XXX' )
			 );
  end;
  procedure test( p_key	raw, p_txt raw,	p_expected raw := null )
  is
    t_encrypted	raw(8);
  begin
    idea_init( p_key );
    t_encrypted	:= idea_block( p_txt, Z	);
    dbms_output.put_line( t_encrypted );
    if t_encrypted != p_expected
    then
      dbms_output.put_line( 'error!' );
    end	if;
    if p_txt !=	idea_block( idea_block(	p_txt, Z ), DK )
    then
      dbms_output.put_line( 'error!!!' );
    end	if;
  end;
begin
  test(	'2BD6459F82C5B300952C49104881FF48', 'F129A6601EF62A47',	'EA024714AD5C4D84' );
  test(	'000102030405060708090A0B0C0D0E0F', 'DB2D4A92AA68273F',	'0011223344556677' );
  test(	'FEFEFEFEFEFEFEFEFEFEFEFEFEFEFEFE', 'C7E3F87FFE503CC3',	'FEFEFEFEFEFEFEFE' );
  test(	'E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2E2', '9933DF5A78A355A8',	'E2E2E2E2E2E2E2E2' );
  test(	'006400c8012c019001f4025802bc0320', '05320a6414c819fa',	'65BE87E7A2538AED' );
  test(	'80000000000000000000000000000000', '0000000000000000',	'B1F5F7F87901370F' );
  test(	'10000000000000000000000000000000', '0000000000000000',	'754A03CE08DB7DAA' );
  test(	'00000000000000000000000000000001', '0000000000000000',	'C57ADBDE27BC26CF' );
end;





des ***********
declare
  t_iv raw(16);
  t_key	raw(32);
  t_secret raw(48);
  t_encr raw(48);
  t_type pls_integer;
  type tp_des is table of integer;
--
    -- Block Cipher Algorithms
    ENCRYPT_DES	       CONSTANT	PLS_INTEGER	       :=     1;  -- 0x0001
    ENCRYPT_3DES_2KEY  CONSTANT	PLS_INTEGER	       :=     2;  -- 0x0002
    ENCRYPT_3DES       CONSTANT	PLS_INTEGER	       :=     3;  -- 0x0003
    ENCRYPT_AES	       CONSTANT	PLS_INTEGER	       :=     4;  -- 0x0004
    ENCRYPT_PBE_MD5DES CONSTANT	PLS_INTEGER	       :=     5;  -- 0x0005
    ENCRYPT_AES128     CONSTANT	PLS_INTEGER	       :=     6;  -- 0x0006
    ENCRYPT_AES192     CONSTANT	PLS_INTEGER	       :=     7;  -- 0x0007
    ENCRYPT_AES256     CONSTANT	PLS_INTEGER	       :=     8;  -- 0x0008
    -- Block Cipher Chaining Modifiers
    CHAIN_CBC	       CONSTANT	PLS_INTEGER	       :=   256;  -- 0x0100
    CHAIN_CFB	       CONSTANT	PLS_INTEGER	       :=   512;  -- 0x0200
    CHAIN_ECB	       CONSTANT	PLS_INTEGER	       :=   768;  -- 0x0300
    CHAIN_OFB	       CONSTANT	PLS_INTEGER	       :=  1024;  -- 0x0400
    -- Block Cipher Padding Modifiers
    PAD_PKCS5	       CONSTANT	PLS_INTEGER	       :=  4096;  -- 0x1000
    PAD_NONE	       CONSTANT	PLS_INTEGER	       :=  8192;  -- 0x2000
    PAD_ZERO	       CONSTANT	PLS_INTEGER	       := 12288;  -- 0x3000
    PAD_ORCL	       CONSTANT	PLS_INTEGER	       := 16384;  -- 0x4000
    PAD_OneAndZeroes   CONSTANT	PLS_INTEGER	       := 20480;  -- 0x5000
    PAD_ANSI_X923      CONSTANT	PLS_INTEGER	       := 24576;  -- 0x6000
    -- Stream Cipher Algorithms
    ENCRYPT_RC4        CONSTANT PLS_INTEGER            :=   129;  -- 0x0081
--
	SP1 tp_des := tp_des(
	to_number( '01010400', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '00010000', 'xxxxxxxx' ), to_number( '01010404', 'xxxxxxxx' ),
	to_number( '01010004', 'xxxxxxxx' ), to_number(	'00010404', 'xxxxxxxx' ), to_number( '00000004', 'xxxxxxxx' ), to_number( '00010000', 'xxxxxxxx' ),
	to_number( '00000400', 'xxxxxxxx' ), to_number(	'01010400', 'xxxxxxxx' ), to_number( '01010404', 'xxxxxxxx' ), to_number( '00000400', 'xxxxxxxx' ),
	to_number( '01000404', 'xxxxxxxx' ), to_number(	'01010004', 'xxxxxxxx' ), to_number( '01000000', 'xxxxxxxx' ), to_number( '00000004', 'xxxxxxxx' ),
	to_number( '00000404', 'xxxxxxxx' ), to_number(	'01000400', 'xxxxxxxx' ), to_number( '01000400', 'xxxxxxxx' ), to_number( '00010400', 'xxxxxxxx' ),
	to_number( '00010400', 'xxxxxxxx' ), to_number(	'01010000', 'xxxxxxxx' ), to_number( '01010000', 'xxxxxxxx' ), to_number( '01000404', 'xxxxxxxx' ),
	to_number( '00010004', 'xxxxxxxx' ), to_number(	'01000004', 'xxxxxxxx' ), to_number( '01000004', 'xxxxxxxx' ), to_number( '00010004', 'xxxxxxxx' ),
	to_number( '00000000', 'xxxxxxxx' ), to_number(	'00000404', 'xxxxxxxx' ), to_number( '00010404', 'xxxxxxxx' ), to_number( '01000000', 'xxxxxxxx' ),
	to_number( '00010000', 'xxxxxxxx' ), to_number(	'01010404', 'xxxxxxxx' ), to_number( '00000004', 'xxxxxxxx' ), to_number( '01010000', 'xxxxxxxx' ),
	to_number( '01010400', 'xxxxxxxx' ), to_number(	'01000000', 'xxxxxxxx' ), to_number( '01000000', 'xxxxxxxx' ), to_number( '00000400', 'xxxxxxxx' ),
	to_number( '01010004', 'xxxxxxxx' ), to_number(	'00010000', 'xxxxxxxx' ), to_number( '00010400', 'xxxxxxxx' ), to_number( '01000004', 'xxxxxxxx' ),
	to_number( '00000400', 'xxxxxxxx' ), to_number(	'00000004', 'xxxxxxxx' ), to_number( '01000404', 'xxxxxxxx' ), to_number( '00010404', 'xxxxxxxx' ),
	to_number( '01010404', 'xxxxxxxx' ), to_number(	'00010004', 'xxxxxxxx' ), to_number( '01010000', 'xxxxxxxx' ), to_number( '01000404', 'xxxxxxxx' ),
	to_number( '01000004', 'xxxxxxxx' ), to_number(	'00000404', 'xxxxxxxx' ), to_number( '00010404', 'xxxxxxxx' ), to_number( '01010400', 'xxxxxxxx' ),
	to_number( '00000404', 'xxxxxxxx' ), to_number(	'01000400', 'xxxxxxxx' ), to_number( '01000400', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ),
	to_number( '00010004', 'xxxxxxxx' ), to_number(	'00010400', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '01010004', 'xxxxxxxx' )
    );
	SP2 tp_des := tp_des(
	to_number( '80108020', 'xxxxxxxx' ), to_number(	'80008000', 'xxxxxxxx' ), to_number( '00008000', 'xxxxxxxx' ), to_number( '00108020', 'xxxxxxxx' ),
	to_number( '00100000', 'xxxxxxxx' ), to_number(	'00000020', 'xxxxxxxx' ), to_number( '80100020', 'xxxxxxxx' ), to_number( '80008020', 'xxxxxxxx' ),
	to_number( '80000020', 'xxxxxxxx' ), to_number(	'80108020', 'xxxxxxxx' ), to_number( '80108000', 'xxxxxxxx' ), to_number( '80000000', 'xxxxxxxx' ),
	to_number( '80008000', 'xxxxxxxx' ), to_number(	'00100000', 'xxxxxxxx' ), to_number( '00000020', 'xxxxxxxx' ), to_number( '80100020', 'xxxxxxxx' ),
	to_number( '00108000', 'xxxxxxxx' ), to_number(	'00100020', 'xxxxxxxx' ), to_number( '80008020', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ),
	to_number( '80000000', 'xxxxxxxx' ), to_number(	'00008000', 'xxxxxxxx' ), to_number( '00108020', 'xxxxxxxx' ), to_number( '80100000', 'xxxxxxxx' ),
	to_number( '00100020', 'xxxxxxxx' ), to_number(	'80000020', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '00108000', 'xxxxxxxx' ),
	to_number( '00008020', 'xxxxxxxx' ), to_number(	'80108000', 'xxxxxxxx' ), to_number( '80100000', 'xxxxxxxx' ), to_number( '00008020', 'xxxxxxxx' ),
	to_number( '00000000', 'xxxxxxxx' ), to_number(	'00108020', 'xxxxxxxx' ), to_number( '80100020', 'xxxxxxxx' ), to_number( '00100000', 'xxxxxxxx' ),
	to_number( '80008020', 'xxxxxxxx' ), to_number(	'80100000', 'xxxxxxxx' ), to_number( '80108000', 'xxxxxxxx' ), to_number( '00008000', 'xxxxxxxx' ),
	to_number( '80100000', 'xxxxxxxx' ), to_number(	'80008000', 'xxxxxxxx' ), to_number( '00000020', 'xxxxxxxx' ), to_number( '80108020', 'xxxxxxxx' ),
	to_number( '00108020', 'xxxxxxxx' ), to_number(	'00000020', 'xxxxxxxx' ), to_number( '00008000', 'xxxxxxxx' ), to_number( '80000000', 'xxxxxxxx' ),
	to_number( '00008020', 'xxxxxxxx' ), to_number(	'80108000', 'xxxxxxxx' ), to_number( '00100000', 'xxxxxxxx' ), to_number( '80000020', 'xxxxxxxx' ),
	to_number( '00100020', 'xxxxxxxx' ), to_number(	'80008020', 'xxxxxxxx' ), to_number( '80000020', 'xxxxxxxx' ), to_number( '00100020', 'xxxxxxxx' ),
	to_number( '00108000', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '80008000', 'xxxxxxxx' ), to_number( '00008020', 'xxxxxxxx' ),
	to_number( '80000000', 'xxxxxxxx' ), to_number(	'80100020', 'xxxxxxxx' ), to_number( '80108020', 'xxxxxxxx' ), to_number( '00108000', 'xxxxxxxx' )
    );
	SP3 tp_des := tp_des(
	to_number( '00000208', 'xxxxxxxx' ), to_number(	'08020200', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '08020008', 'xxxxxxxx' ),
	to_number( '08000200', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '00020208', 'xxxxxxxx' ), to_number( '08000200', 'xxxxxxxx' ),
	to_number( '00020008', 'xxxxxxxx' ), to_number(	'08000008', 'xxxxxxxx' ), to_number( '08000008', 'xxxxxxxx' ), to_number( '00020000', 'xxxxxxxx' ),
	to_number( '08020208', 'xxxxxxxx' ), to_number(	'00020008', 'xxxxxxxx' ), to_number( '08020000', 'xxxxxxxx' ), to_number( '00000208', 'xxxxxxxx' ),
	to_number( '08000000', 'xxxxxxxx' ), to_number(	'00000008', 'xxxxxxxx' ), to_number( '08020200', 'xxxxxxxx' ), to_number( '00000200', 'xxxxxxxx' ),
	to_number( '00020200', 'xxxxxxxx' ), to_number(	'08020000', 'xxxxxxxx' ), to_number( '08020008', 'xxxxxxxx' ), to_number( '00020208', 'xxxxxxxx' ),
	to_number( '08000208', 'xxxxxxxx' ), to_number(	'00020200', 'xxxxxxxx' ), to_number( '00020000', 'xxxxxxxx' ), to_number( '08000208', 'xxxxxxxx' ),
	to_number( '00000008', 'xxxxxxxx' ), to_number(	'08020208', 'xxxxxxxx' ), to_number( '00000200', 'xxxxxxxx' ), to_number( '08000000', 'xxxxxxxx' ),
	to_number( '08020200', 'xxxxxxxx' ), to_number(	'08000000', 'xxxxxxxx' ), to_number( '00020008', 'xxxxxxxx' ), to_number( '00000208', 'xxxxxxxx' ),
	to_number( '00020000', 'xxxxxxxx' ), to_number(	'08020200', 'xxxxxxxx' ), to_number( '08000200', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ),
	to_number( '00000200', 'xxxxxxxx' ), to_number(	'00020008', 'xxxxxxxx' ), to_number( '08020208', 'xxxxxxxx' ), to_number( '08000200', 'xxxxxxxx' ),
	to_number( '08000008', 'xxxxxxxx' ), to_number(	'00000200', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '08020008', 'xxxxxxxx' ),
	to_number( '08000208', 'xxxxxxxx' ), to_number(	'00020000', 'xxxxxxxx' ), to_number( '08000000', 'xxxxxxxx' ), to_number( '08020208', 'xxxxxxxx' ),
	to_number( '00000008', 'xxxxxxxx' ), to_number(	'00020208', 'xxxxxxxx' ), to_number( '00020200', 'xxxxxxxx' ), to_number( '08000008', 'xxxxxxxx' ),
	to_number( '08020000', 'xxxxxxxx' ), to_number(	'08000208', 'xxxxxxxx' ), to_number( '00000208', 'xxxxxxxx' ), to_number( '08020000', 'xxxxxxxx' ),
	to_number( '00020208', 'xxxxxxxx' ), to_number(	'00000008', 'xxxxxxxx' ), to_number( '08020008', 'xxxxxxxx' ), to_number( '00020200', 'xxxxxxxx' )
    );
	SP4 tp_des := tp_des(
	to_number( '00802001', 'xxxxxxxx' ), to_number(	'00002081', 'xxxxxxxx' ), to_number( '00002081', 'xxxxxxxx' ), to_number( '00000080', 'xxxxxxxx' ),
	to_number( '00802080', 'xxxxxxxx' ), to_number(	'00800081', 'xxxxxxxx' ), to_number( '00800001', 'xxxxxxxx' ), to_number( '00002001', 'xxxxxxxx' ),
	to_number( '00000000', 'xxxxxxxx' ), to_number(	'00802000', 'xxxxxxxx' ), to_number( '00802000', 'xxxxxxxx' ), to_number( '00802081', 'xxxxxxxx' ),
	to_number( '00000081', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '00800080', 'xxxxxxxx' ), to_number( '00800001', 'xxxxxxxx' ),
	to_number( '00000001', 'xxxxxxxx' ), to_number(	'00002000', 'xxxxxxxx' ), to_number( '00800000', 'xxxxxxxx' ), to_number( '00802001', 'xxxxxxxx' ),
	to_number( '00000080', 'xxxxxxxx' ), to_number(	'00800000', 'xxxxxxxx' ), to_number( '00002001', 'xxxxxxxx' ), to_number( '00002080', 'xxxxxxxx' ),
	to_number( '00800081', 'xxxxxxxx' ), to_number(	'00000001', 'xxxxxxxx' ), to_number( '00002080', 'xxxxxxxx' ), to_number( '00800080', 'xxxxxxxx' ),
	to_number( '00002000', 'xxxxxxxx' ), to_number(	'00802080', 'xxxxxxxx' ), to_number( '00802081', 'xxxxxxxx' ), to_number( '00000081', 'xxxxxxxx' ),
	to_number( '00800080', 'xxxxxxxx' ), to_number(	'00800001', 'xxxxxxxx' ), to_number( '00802000', 'xxxxxxxx' ), to_number( '00802081', 'xxxxxxxx' ),
	to_number( '00000081', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '00802000', 'xxxxxxxx' ),
	to_number( '00002080', 'xxxxxxxx' ), to_number(	'00800080', 'xxxxxxxx' ), to_number( '00800081', 'xxxxxxxx' ), to_number( '00000001', 'xxxxxxxx' ),
	to_number( '00802001', 'xxxxxxxx' ), to_number(	'00002081', 'xxxxxxxx' ), to_number( '00002081', 'xxxxxxxx' ), to_number( '00000080', 'xxxxxxxx' ),
	to_number( '00802081', 'xxxxxxxx' ), to_number(	'00000081', 'xxxxxxxx' ), to_number( '00000001', 'xxxxxxxx' ), to_number( '00002000', 'xxxxxxxx' ),
	to_number( '00800001', 'xxxxxxxx' ), to_number(	'00002001', 'xxxxxxxx' ), to_number( '00802080', 'xxxxxxxx' ), to_number( '00800081', 'xxxxxxxx' ),
	to_number( '00002001', 'xxxxxxxx' ), to_number(	'00002080', 'xxxxxxxx' ), to_number( '00800000', 'xxxxxxxx' ), to_number( '00802001', 'xxxxxxxx' ),
	to_number( '00000080', 'xxxxxxxx' ), to_number(	'00800000', 'xxxxxxxx' ), to_number( '00002000', 'xxxxxxxx' ), to_number( '00802080', 'xxxxxxxx' )
    );
	SP5 tp_des := tp_des(
	to_number( '00000100', 'xxxxxxxx' ), to_number(	'02080100', 'xxxxxxxx' ), to_number( '02080000', 'xxxxxxxx' ), to_number( '42000100', 'xxxxxxxx' ),
	to_number( '00080000', 'xxxxxxxx' ), to_number(	'00000100', 'xxxxxxxx' ), to_number( '40000000', 'xxxxxxxx' ), to_number( '02080000', 'xxxxxxxx' ),
	to_number( '40080100', 'xxxxxxxx' ), to_number(	'00080000', 'xxxxxxxx' ), to_number( '02000100', 'xxxxxxxx' ), to_number( '40080100', 'xxxxxxxx' ),
	to_number( '42000100', 'xxxxxxxx' ), to_number(	'42080000', 'xxxxxxxx' ), to_number( '00080100', 'xxxxxxxx' ), to_number( '40000000', 'xxxxxxxx' ),
	to_number( '02000000', 'xxxxxxxx' ), to_number(	'40080000', 'xxxxxxxx' ), to_number( '40080000', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ),
	to_number( '40000100', 'xxxxxxxx' ), to_number(	'42080100', 'xxxxxxxx' ), to_number( '42080100', 'xxxxxxxx' ), to_number( '02000100', 'xxxxxxxx' ),
	to_number( '42080000', 'xxxxxxxx' ), to_number(	'40000100', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '42000000', 'xxxxxxxx' ),
	to_number( '02080100', 'xxxxxxxx' ), to_number(	'02000000', 'xxxxxxxx' ), to_number( '42000000', 'xxxxxxxx' ), to_number( '00080100', 'xxxxxxxx' ),
	to_number( '00080000', 'xxxxxxxx' ), to_number(	'42000100', 'xxxxxxxx' ), to_number( '00000100', 'xxxxxxxx' ), to_number( '02000000', 'xxxxxxxx' ),
	to_number( '40000000', 'xxxxxxxx' ), to_number(	'02080000', 'xxxxxxxx' ), to_number( '42000100', 'xxxxxxxx' ), to_number( '40080100', 'xxxxxxxx' ),
	to_number( '02000100', 'xxxxxxxx' ), to_number(	'40000000', 'xxxxxxxx' ), to_number( '42080000', 'xxxxxxxx' ), to_number( '02080100', 'xxxxxxxx' ),
	to_number( '40080100', 'xxxxxxxx' ), to_number(	'00000100', 'xxxxxxxx' ), to_number( '02000000', 'xxxxxxxx' ), to_number( '42080000', 'xxxxxxxx' ),
	to_number( '42080100', 'xxxxxxxx' ), to_number(	'00080100', 'xxxxxxxx' ), to_number( '42000000', 'xxxxxxxx' ), to_number( '42080100', 'xxxxxxxx' ),
	to_number( '02080000', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '40080000', 'xxxxxxxx' ), to_number( '42000000', 'xxxxxxxx' ),
	to_number( '00080100', 'xxxxxxxx' ), to_number(	'02000100', 'xxxxxxxx' ), to_number( '40000100', 'xxxxxxxx' ), to_number( '00080000', 'xxxxxxxx' ),
	to_number( '00000000', 'xxxxxxxx' ), to_number(	'40080000', 'xxxxxxxx' ), to_number( '02080100', 'xxxxxxxx' ), to_number( '40000100', 'xxxxxxxx' )
    );
	SP6 tp_des := tp_des(
	to_number( '20000010', 'xxxxxxxx' ), to_number(	'20400000', 'xxxxxxxx' ), to_number( '00004000', 'xxxxxxxx' ), to_number( '20404010', 'xxxxxxxx' ),
	to_number( '20400000', 'xxxxxxxx' ), to_number(	'00000010', 'xxxxxxxx' ), to_number( '20404010', 'xxxxxxxx' ), to_number( '00400000', 'xxxxxxxx' ),
	to_number( '20004000', 'xxxxxxxx' ), to_number(	'00404010', 'xxxxxxxx' ), to_number( '00400000', 'xxxxxxxx' ), to_number( '20000010', 'xxxxxxxx' ),
	to_number( '00400010', 'xxxxxxxx' ), to_number(	'20004000', 'xxxxxxxx' ), to_number( '20000000', 'xxxxxxxx' ), to_number( '00004010', 'xxxxxxxx' ),
	to_number( '00000000', 'xxxxxxxx' ), to_number(	'00400010', 'xxxxxxxx' ), to_number( '20004010', 'xxxxxxxx' ), to_number( '00004000', 'xxxxxxxx' ),
	to_number( '00404000', 'xxxxxxxx' ), to_number(	'20004010', 'xxxxxxxx' ), to_number( '00000010', 'xxxxxxxx' ), to_number( '20400010', 'xxxxxxxx' ),
	to_number( '20400010', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '00404010', 'xxxxxxxx' ), to_number( '20404000', 'xxxxxxxx' ),
	to_number( '00004010', 'xxxxxxxx' ), to_number(	'00404000', 'xxxxxxxx' ), to_number( '20404000', 'xxxxxxxx' ), to_number( '20000000', 'xxxxxxxx' ),
	to_number( '20004000', 'xxxxxxxx' ), to_number(	'00000010', 'xxxxxxxx' ), to_number( '20400010', 'xxxxxxxx' ), to_number( '00404000', 'xxxxxxxx' ),
	to_number( '20404010', 'xxxxxxxx' ), to_number(	'00400000', 'xxxxxxxx' ), to_number( '00004010', 'xxxxxxxx' ), to_number( '20000010', 'xxxxxxxx' ),
	to_number( '00400000', 'xxxxxxxx' ), to_number(	'20004000', 'xxxxxxxx' ), to_number( '20000000', 'xxxxxxxx' ), to_number( '00004010', 'xxxxxxxx' ),
	to_number( '20000010', 'xxxxxxxx' ), to_number(	'20404010', 'xxxxxxxx' ), to_number( '00404000', 'xxxxxxxx' ), to_number( '20400000', 'xxxxxxxx' ),
	to_number( '00404010', 'xxxxxxxx' ), to_number(	'20404000', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '20400010', 'xxxxxxxx' ),
	to_number( '00000010', 'xxxxxxxx' ), to_number(	'00004000', 'xxxxxxxx' ), to_number( '20400000', 'xxxxxxxx' ), to_number( '00404010', 'xxxxxxxx' ),
	to_number( '00004000', 'xxxxxxxx' ), to_number(	'00400010', 'xxxxxxxx' ), to_number( '20004010', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ),
	to_number( '20404000', 'xxxxxxxx' ), to_number(	'20000000', 'xxxxxxxx' ), to_number( '00400010', 'xxxxxxxx' ), to_number( '20004010', 'xxxxxxxx' )
    );
	SP7 tp_des := tp_des(
	to_number( '00200000', 'xxxxxxxx' ), to_number(	'04200002', 'xxxxxxxx' ), to_number( '04000802', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ),
	to_number( '00000800', 'xxxxxxxx' ), to_number(	'04000802', 'xxxxxxxx' ), to_number( '00200802', 'xxxxxxxx' ), to_number( '04200800', 'xxxxxxxx' ),
	to_number( '04200802', 'xxxxxxxx' ), to_number(	'00200000', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '04000002', 'xxxxxxxx' ),
	to_number( '00000002', 'xxxxxxxx' ), to_number(	'04000000', 'xxxxxxxx' ), to_number( '04200002', 'xxxxxxxx' ), to_number( '00000802', 'xxxxxxxx' ),
	to_number( '04000800', 'xxxxxxxx' ), to_number(	'00200802', 'xxxxxxxx' ), to_number( '00200002', 'xxxxxxxx' ), to_number( '04000800', 'xxxxxxxx' ),
	to_number( '04000002', 'xxxxxxxx' ), to_number(	'04200000', 'xxxxxxxx' ), to_number( '04200800', 'xxxxxxxx' ), to_number( '00200002', 'xxxxxxxx' ),
	to_number( '04200000', 'xxxxxxxx' ), to_number(	'00000800', 'xxxxxxxx' ), to_number( '00000802', 'xxxxxxxx' ), to_number( '04200802', 'xxxxxxxx' ),
	to_number( '00200800', 'xxxxxxxx' ), to_number(	'00000002', 'xxxxxxxx' ), to_number( '04000000', 'xxxxxxxx' ), to_number( '00200800', 'xxxxxxxx' ),
	to_number( '04000000', 'xxxxxxxx' ), to_number(	'00200800', 'xxxxxxxx' ), to_number( '00200000', 'xxxxxxxx' ), to_number( '04000802', 'xxxxxxxx' ),
	to_number( '04000802', 'xxxxxxxx' ), to_number(	'04200002', 'xxxxxxxx' ), to_number( '04200002', 'xxxxxxxx' ), to_number( '00000002', 'xxxxxxxx' ),
	to_number( '00200002', 'xxxxxxxx' ), to_number(	'04000000', 'xxxxxxxx' ), to_number( '04000800', 'xxxxxxxx' ), to_number( '00200000', 'xxxxxxxx' ),
	to_number( '04200800', 'xxxxxxxx' ), to_number(	'00000802', 'xxxxxxxx' ), to_number( '00200802', 'xxxxxxxx' ), to_number( '04200800', 'xxxxxxxx' ),
	to_number( '00000802', 'xxxxxxxx' ), to_number(	'04000002', 'xxxxxxxx' ), to_number( '04200802', 'xxxxxxxx' ), to_number( '04200000', 'xxxxxxxx' ),
	to_number( '00200800', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '00000002', 'xxxxxxxx' ), to_number( '04200802', 'xxxxxxxx' ),
	to_number( '00000000', 'xxxxxxxx' ), to_number(	'00200802', 'xxxxxxxx' ), to_number( '04200000', 'xxxxxxxx' ), to_number( '00000800', 'xxxxxxxx' ),
	to_number( '04000002', 'xxxxxxxx' ), to_number(	'04000800', 'xxxxxxxx' ), to_number( '00000800', 'xxxxxxxx' ), to_number( '00200002', 'xxxxxxxx' )
    );
	SP8 tp_des := tp_des(
	to_number( '10001040', 'xxxxxxxx' ), to_number(	'00001000', 'xxxxxxxx' ), to_number( '00040000', 'xxxxxxxx' ), to_number( '10041040', 'xxxxxxxx' ),
	to_number( '10000000', 'xxxxxxxx' ), to_number(	'10001040', 'xxxxxxxx' ), to_number( '00000040', 'xxxxxxxx' ), to_number( '10000000', 'xxxxxxxx' ),
	to_number( '00040040', 'xxxxxxxx' ), to_number(	'10040000', 'xxxxxxxx' ), to_number( '10041040', 'xxxxxxxx' ), to_number( '00041000', 'xxxxxxxx' ),
	to_number( '10041000', 'xxxxxxxx' ), to_number(	'00041040', 'xxxxxxxx' ), to_number( '00001000', 'xxxxxxxx' ), to_number( '00000040', 'xxxxxxxx' ),
	to_number( '10040000', 'xxxxxxxx' ), to_number(	'10000040', 'xxxxxxxx' ), to_number( '10001000', 'xxxxxxxx' ), to_number( '00001040', 'xxxxxxxx' ),
	to_number( '00041000', 'xxxxxxxx' ), to_number(	'00040040', 'xxxxxxxx' ), to_number( '10040040', 'xxxxxxxx' ), to_number( '10041000', 'xxxxxxxx' ),
	to_number( '00001040', 'xxxxxxxx' ), to_number(	'00000000', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ), to_number( '10040040', 'xxxxxxxx' ),
	to_number( '10000040', 'xxxxxxxx' ), to_number(	'10001000', 'xxxxxxxx' ), to_number( '00041040', 'xxxxxxxx' ), to_number( '00040000', 'xxxxxxxx' ),
	to_number( '00041040', 'xxxxxxxx' ), to_number(	'00040000', 'xxxxxxxx' ), to_number( '10041000', 'xxxxxxxx' ), to_number( '00001000', 'xxxxxxxx' ),
	to_number( '00000040', 'xxxxxxxx' ), to_number(	'10040040', 'xxxxxxxx' ), to_number( '00001000', 'xxxxxxxx' ), to_number( '00041040', 'xxxxxxxx' ),
	to_number( '10001000', 'xxxxxxxx' ), to_number(	'00000040', 'xxxxxxxx' ), to_number( '10000040', 'xxxxxxxx' ), to_number( '10040000', 'xxxxxxxx' ),
	to_number( '10040040', 'xxxxxxxx' ), to_number(	'10000000', 'xxxxxxxx' ), to_number( '00040000', 'xxxxxxxx' ), to_number( '10001040', 'xxxxxxxx' ),
	to_number( '00000000', 'xxxxxxxx' ), to_number(	'10041040', 'xxxxxxxx' ), to_number( '00040040', 'xxxxxxxx' ), to_number( '10000040', 'xxxxxxxx' ),
	to_number( '10040000', 'xxxxxxxx' ), to_number(	'10001000', 'xxxxxxxx' ), to_number( '10001040', 'xxxxxxxx' ), to_number( '00000000', 'xxxxxxxx' ),
	to_number( '10041040', 'xxxxxxxx' ), to_number(	'00041000', 'xxxxxxxx' ), to_number( '00041000', 'xxxxxxxx' ), to_number( '00001040', 'xxxxxxxx' ),
	to_number( '00001040', 'xxxxxxxx' ), to_number(	'00040040', 'xxxxxxxx' ), to_number( '10000000', 'xxxxxxxx' ), to_number( '10041000', 'xxxxxxxx' )
    );
--
  function bitor( x integer, y integer )
  return integer
  is
  begin
    return bitand( x + y - bitand( x, y	), 4294967295 );
  end;
--
  function bitxor( x integer, y	integer	)
  return integer
  is
  begin
    return bitand( x + y - 2 * bitand( x, y ), 4294967295 );
  end;
--
  function shl(	x integer, b pls_integer )
  return integer
  is
  begin
    return bitand( x * case b
			 when 1	 then 2
			 when 2	 then 4
			 when 3	 then 8
			 when 4	 then 16
			 when 5	 then 32
			 when 6	 then 64
			 when 7	 then 128
			 when 8	 then 256
			 when 9	 then 512
			 when 10 then 1024
			 when 11 then 2048
			 when 12 then 4096
			 when 13 then 8192
			 when 14 then 16384
			 when 15 then 32768
			 when 16 then 65536
			 when 24 then 16777216
			 when 28 then 268435456
			 when 31 then 2147483648
		       end
		 , 4294967295
		 );
  end;
--
  function shr(	x integer, b pls_integer )
  return integer
  is
  begin
    return trunc( x / case b
			when 1	then 2
			when 2	then 4
			when 3	then 8
			when 4	then 16
			when 5	then 32
			when 6	then 64
			when 7	then 128
			when 8	then 256
			when 9	then 512
			when 10	then 1024
			when 11	then 2048
			when 12	then 4096
			when 13	then 8192
			when 14	then 16384
			when 15	then 32768
			when 16	then 65536
			when 24	then 16777216
			when 28	then 268435456
		      end );
  end;
--
  procedure deskey( p_key raw, p_keys out tp_des, p_encrypt boolean )
  is
    bytebit tp_des := tp_des( 128, 64, 32, 16, 8, 4, 2,	1 );
    bigbyte tp_des := tp_des( to_number( '800000', 'XXXXXX' ), to_number( '400000', 'XXXXXX' ),	to_number( '200000', 'XXXXXX' ), to_number( '100000', 'XXXXXX' )
			    , to_number( '080000', 'XXXXXX' ), to_number( '040000', 'XXXXXX' ),	to_number( '020000', 'XXXXXX' ), to_number( '010000', 'XXXXXX' )
			    , to_number( '008000', 'XXXXXX' ), to_number( '004000', 'XXXXXX' ),	to_number( '002000', 'XXXXXX' ), to_number( '001000', 'XXXXXX' )
			    , to_number( '000800', 'XXXXXX' ), to_number( '000400', 'XXXXXX' ),	to_number( '000200', 'XXXXXX' ), to_number( '000100', 'XXXXXX' )
			    , to_number( '000080', 'XXXXXX' ), to_number( '000040', 'XXXXXX' ),	to_number( '000020', 'XXXXXX' ), to_number( '000010', 'XXXXXX' )
			    , to_number( '000008', 'XXXXXX' ), to_number( '000004', 'XXXXXX' ),	to_number( '000002', 'XXXXXX' ), to_number( '000001', 'XXXXXX' )
			    );
    pcl	tp_des := tp_des( 56, 48, 40, 32, 24, 16,  8
			,  0, 57, 49, 41, 33, 25, 17
			,  9,  1, 58, 50, 42, 34, 26
			, 18, 10,  2, 59, 51, 43, 35
			, 62, 54, 46, 38, 30, 22, 14
			,  6, 61, 53, 45, 37, 29, 21
			, 13,  5, 60, 52, 44, 36, 28
			, 20, 12,  4, 27, 19, 11, 3
			);
    pc2	tp_des := tp_des( 13, 16, 10, 23,  0,  4
			,  2, 27, 14,  5, 20,  9
			, 22, 18, 11, 3	, 25,  7
			, 15,  6, 26, 19, 12,  1
			, 40, 51, 30, 36, 46, 54
			, 29, 39, 50, 44, 32, 47
			, 43, 48, 38, 55, 33, 52
			, 45, 41, 49, 35, 28, 31
			);
    totrot tp_des := tp_des( 1,	2, 4, 6, 8, 10,	12, 14
			   , 15, 17, 19, 21, 23, 25, 27, 28
			   );
    t_key tp_des := tp_des();
    pclm tp_des	:= tp_des();
    pcr	tp_des := tp_des();
    kn tp_des := tp_des();
    t_l	pls_integer;
    t_m	pls_integer;
    t_n	pls_integer;
    raw0 number;
    raw1 number;
    t_tmp number;
    rawi pls_integer;
    knli pls_integer;
  begin
    t_key.extend(8);
    for	i in 1 .. 8
    loop
     t_key(i) := to_number( utl_raw.substr( p_key, i, 1	), 'XX'	);
    end	loop;
    pclm.extend(56);
    for	j in 1 .. 56
    loop
      pclm(j) := sign( bitand( t_key( trunc( pcl( j ) /	8 ) + 1	), bytebit( bitand( pcl( j ), 7	) + 1 )	) );
    end	loop;
    kn.extend(32);
    pcr.extend(56);
    for	i in 0 .. 15
    loop
      t_m := case when p_encrypt then i	else 15	- i end	* 2;
      t_n := t_m + 1;
      kn(t_m+1)	:= 0;
      kn(t_n+1)	:= 0;
      for j in 0 .. 27
      loop
	t_l := j + totrot(i+1);
	if t_l < 28
	then
	  pcr(j+1) := pclm( t_l	+ 1 );
	else
	  pcr(j+1) := pclm( t_l	- 28 + 1 );
	end if;
      end loop;
      for j in 28 .. 55
      loop
	t_l := j + totrot(i+1);
	if t_l < 56
	then
	  pcr(j+1) := pclm( t_l	+ 1 );
	else
	  pcr(j+1) := pclm( t_l	- 28 + 1 );
	end if;
      end loop;
      for j in 0 .. 23
      loop
	if pcr(	pc2( j + 1 ) + 1 ) != 0
	then
	  kn( t_m + 1 )	:= bitor( kn( t_m + 1 ), bigbyte( j + 1	) );
	end if;
	if pcr(	pc2( j + 24 + 1	) + 1 )	!= 0
	then
	  kn( t_n + 1 )	:= bitor( kn( t_n + 1 ), bigbyte( j + 1	) );
	end if;
      end loop;
    end	loop;
--
    p_keys := tp_des();
    p_keys.extend(32);
    rawi := 1;
    knli := 1;
    for	i in 0 .. 15
    loop
      raw0 := kn(rawi);
      rawi := rawi + 1;
      raw1 := kn(rawi);
      rawi := rawi + 1;
      t_tmp := bitand( raw0, to_number(	'fc0000', 'xxxxxx' ) ) * 64;
      t_tmp := bitor( t_tmp, bitand( raw0, to_number( '0fc0', 'xxxx' ) ) * 1024	);
      t_tmp := bitor( t_tmp, bitand( raw1, to_number( 'fc0000',	'xxxxxx' ) ) / 1024 );
      t_tmp := bitor( t_tmp, bitand( raw1, to_number( '0fc0', 'xxxx' ) ) / 64 );
      p_keys(knli) := t_tmp;
      knli := knli + 1;
      t_tmp := bitand( raw0, to_number(	'03f000', 'xxxxxx' ) ) * 4096;
      t_tmp := bitor( t_tmp, bitand( raw0, to_number( '3f', 'xx' ) ) * 65536 );
      t_tmp := bitor( t_tmp, bitand( raw1, to_number( '03f000',	'xxxxxx' ) ) / 16 );
      t_tmp := bitor( t_tmp, bitand( raw1, to_number( '3f', 'xx' ) ) );
      p_keys(knli) := t_tmp;
      knli := knli + 1;
    end	loop;
  end;
--
  function des(	p_block	varchar2, p_keys tp_des	)
  return varchar2
  is
    t_left  integer;
    t_right integer;
    t_tmp   integer;
    t_fval  integer;
  begin
    t_left := to_number( substr( p_block, 1, 8 ), 'XXXXXXXX' );
    t_right := to_number( substr( p_block, 9, 8	), 'XXXXXXXX' );
    t_tmp := bitand( bitxor( shr( t_left, 4 ), t_right ), to_number( '0f0f0f0f', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	t_tmp );
    t_left := bitxor( t_left, shl( t_tmp, 4 ) );
    t_tmp := bitand( bitxor( shr( t_left, 16 ),	t_right	), to_number( '0000ffff', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	t_tmp );
    t_left := bitxor( t_left, shl( t_tmp, 16 ) );
    t_tmp := bitand( bitxor( shr( t_right, 2 ),	t_left ), to_number( '33333333', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	shl( t_tmp, 2 )	);
    t_left := bitxor( t_left, t_tmp );
    t_tmp := bitand( bitxor( shr( t_right, 8 ),	t_left ), to_number( '00ff00ff', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	shl( t_tmp, 8 )	);
    t_right := t_right * 2 + sign( bitand( t_right, 2147483648 ) );
    t_left := bitxor( t_left, t_tmp );
    t_tmp := bitand( bitxor( t_right , t_left ), to_number( 'aaaaaaaa',	'xxxxxxxx' ) );
    t_right := bitxor( t_right,	t_tmp );
    t_left := bitxor( t_left, t_tmp );
    t_left := t_left * 2 + sign( bitand( t_left, 2147483648 ) );
--
    for	i in 1 .. 8
    loop
      t_tmp := bitor( shl( t_right, 28 ), shr( t_right,	4 ) );
      t_tmp := bitxor( t_tmp, p_keys( i	* 4 - 3	) );
      t_fval :=	SP7( bitand( t_tmp, 63 ) + 1 );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP5( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP3( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP1( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := bitxor( t_right,	p_keys(	i * 4 -	2 ) );
      t_fval :=	bitor( t_fval, SP8( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP6( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP4( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP2( bitand( t_tmp, 63 )	+ 1 ) );
      t_left :=	bitxor(	t_left,	t_fval );
      t_tmp := bitor( shl( t_left, 28 ), shr( t_left, 4	) );
      t_tmp := bitxor( t_tmp, p_keys( i	* 4 - 1	) );
      t_fval :=	SP7( bitand( t_tmp, 63 ) + 1 );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP5( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP3( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP1( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := bitxor( t_left, p_keys( i * 4 ) );
      t_fval :=	bitor( t_fval, SP8( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP6( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP4( bitand( t_tmp, 63 )	+ 1 ) );
      t_tmp := shr( t_tmp, 8 );
      t_fval :=	bitor( t_fval, SP2( bitand( t_tmp, 63 )	+ 1 ) );
      t_right := bitxor( t_right, t_fval );
    end	loop;
--
    t_right := shl( t_right, 31	) + shr( t_right, 1 );
    t_tmp := bitand( bitxor( t_right , t_left ), to_number( 'aaaaaaaa',	'xxxxxxxx' ) );
    t_right := bitxor( t_right,	t_tmp );
    t_left := bitxor( t_left, t_tmp );
    t_left := shl( t_left, 31 )	+ shr( t_left, 1 );
    t_tmp := bitand( bitxor( shr( t_left, 8 ), t_right ), to_number( '00ff00ff', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	t_tmp );
    t_left := bitxor( t_left, shl( t_tmp, 8 ) );
    t_tmp := bitand( bitxor( shr( t_left, 2 ), t_right ), to_number( '33333333', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	t_tmp );
    t_left := bitxor( t_left, shl( t_tmp, 2 ) );
    t_tmp := bitand( bitxor( shr( t_right, 16 ), t_left	), to_number( '0000ffff', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	shl( t_tmp, 16 ) );
    t_left := bitxor( t_left, t_tmp );
    t_tmp := bitand( bitxor( shr( t_right, 4 ),	t_left ), to_number( '0f0f0f0f', 'xxxxxxxx' ) );
    t_right := bitxor( t_right,	shl( t_tmp, 4 )	);
    t_left := bitxor( t_left, t_tmp );
--
    return to_char( t_right, 'fm0XXXXXXX' ) || to_char(	t_left,	'fm0XXXXXXX' );
  end;
--
  function encrypt_rc4( src raw, key raw )
  return raw
  is
    type tp_arcfour_sbox is table of pls_integer index by pls_integer;
    type tp_arcfour is record
      (  s tp_arcfour_sbox
      ,  i pls_integer
      ,  j pls_integer
      );
    t_tmp pls_integer;
    t_s2 tp_arcfour_sbox;
    t_arcfour tp_arcfour;
    t_encr raw(32767);
  begin
    for  i in 0 .. 255
    loop
      t_arcfour.s(i) :=  i;
    end  loop;
    for  i in 0 .. 255
    loop
      t_s2(i) := to_number( utl_raw.substr( key, mod( i, utl_raw.length( key ) ) + 1, 1 ), 'XX' );
    end  loop;
    t_arcfour.j  := 0;
    for  i in 0 .. 255
    loop
      t_arcfour.j := mod( t_arcfour.j +  t_arcfour.s(i) + t_s2(i), 256 );
      t_tmp := t_arcfour.s(i);
      t_arcfour.s(i) :=  t_arcfour.s( t_arcfour.j );
      t_arcfour.s( t_arcfour.j ) := t_tmp;
    end  loop;
    t_arcfour.i  := 0;
    t_arcfour.j  := 0;
--
    for  i in 1 .. utl_raw.length( src )
    loop
      t_arcfour.i := bitand( t_arcfour.i + 1, 255 );
      t_arcfour.j := bitand( t_arcfour.j + t_arcfour.s(  t_arcfour.i ), 255 );
      t_tmp := t_arcfour.s( t_arcfour.i  );
      t_arcfour.s( t_arcfour.i ) := t_arcfour.s( t_arcfour.j );
      t_arcfour.s( t_arcfour.j ) := t_tmp;
      t_encr := utl_raw.concat( t_encr
                              , to_char( t_arcfour.s( bitand( t_arcfour.s( t_arcfour.i ) + t_arcfour.s( t_arcfour.j ), 255 ) ), 'fm0x' )
                              );
    end  loop;
    return utl_raw.bit_xor( src, t_encr );
  end;
--
  function encrypt( src	raw, typ pls_integer, key raw, iv raw := null )
  return raw
  is
    t_keys tp_des;
    t_keys2 tp_des;
    t_keys3 tp_des;
    t_idx pls_integer;
    t_len pls_integer;
    t_tmp varchar2(32766);
    t_tmp2 varchar2(32766);
    t_encr raw(32767);
    t_plain raw(32767);
    t_padding raw(9);
    t_pad pls_integer;
    t_iv raw(8);
    t_raw raw(8);
    function encr( p raw )
    return raw
    is
      tmp raw(100);
    begin
      case bitand( typ,	15 )
	when ENCRYPT_3DES then
	  tmp := des( des( des(	p, t_keys ), t_keys2 ),	t_keys3	);
	when ENCRYPT_DES then
	  tmp := des( p, t_keys	);
	when ENCRYPT_3DES_2KEY then
	  tmp := des( des( des(	p, t_keys ), t_keys2 ),	t_keys3	);
	else
	  tmp := p;
      end case;
      return tmp;
    end;
  begin
    if bitand( typ, 255 ) = ENCRYPT_RC4
    then
      return encrypt_rc4( src, key );
    end if;
    case bitand( typ, 15 )
      when ENCRYPT_3DES	then
	deskey(	utl_raw.substr(	key, 1,	8 ), t_keys, true );
	deskey(	utl_raw.substr(	key, 9,	8 ), t_keys2, false );
	deskey(	utl_raw.substr(	key, 17, 8 ), t_keys3, true );
      when ENCRYPT_DES then
	deskey(	utl_raw.substr(	key, 1,	8 ), t_keys, true );
      when ENCRYPT_3DES_2KEY then
	deskey(	utl_raw.substr(	key, 1,	8 ), t_keys, true );
	deskey(	utl_raw.substr(	key, 9,	8 ), t_keys2, false );
	t_keys3	:= t_keys;
      else
	null;
    end	case;
    case bitand( typ, 61440 )
      when PAD_PKCS5 then
	t_pad := 8 - mod( utl_raw.length( src ), 8 );
	t_padding := utl_raw.copies( to_char( t_pad, 'fm0X' ), t_pad );
      when PAD_OneAndZeroes then -- OneAndZeroes Padding, ISO/IEC 7816-4
	t_pad := 7 - mod( utl_raw.length( src ), 8 );
	if t_pad = 0
	then
	  t_padding := '80';
	else
	  t_padding := utl_raw.concat( '80', utl_raw.copies( '00', t_pad ) );
	end if;
      when PAD_ANSI_X923 then -- ANSI X.923
	t_pad := 7 - mod( utl_raw.length( src ), 8 );
	if t_pad = 0
	then
	  t_pad	:= 8;
	end if;
	t_padding := utl_raw.concat( utl_raw.copies( '00', t_pad ), to_char( t_pad, 'fm0X' ) );
      when PAD_ZERO then -- zero padding
	t_pad := mod( utl_raw.length( src ), 8 );
	if t_pad > 0
	then
	  t_padding := utl_raw.copies( '00', 8 - t_pad );
	end if;
      when PAD_ORCL then -- zero padding
	t_pad := mod( utl_raw.length( src ), 8 );
	if t_pad > 0
	then
	  t_padding := utl_raw.copies( '00', 8 - t_pad );
	end if;
      else
	null;
    end	case;
    t_plain := utl_raw.concat( src, t_padding );
    t_idx := 1;
    t_len := utl_raw.length( t_plain );
    t_iv := coalesce( iv, utl_raw.copies( '0', 8 ) );
    while t_idx	<= t_len
    loop
      t_tmp := rawtohex( utl_raw.substr( t_plain, t_idx, least(	16376, t_len - t_idx + 1 ) ) );
      t_idx := t_idx + 16376;
      t_tmp2 :=	null;
      for i in 0 .. trunc( length( t_tmp ) / 16	) - 1
      loop
	case bitand( typ, 3840 )
	  when CHAIN_CBC then
	    t_raw := utl_raw.bit_xor( substr( t_tmp, i * 16 + 1, 16 ), t_iv );
	    t_raw := encr( t_raw );
	    t_iv := t_raw;
	  when CHAIN_CFB then
	    t_iv := encr( t_iv );
	    t_raw := utl_raw.bit_xor( substr( t_tmp, i * 16 + 1, 16 ), t_iv );
	    t_iv := t_raw;
	  when CHAIN_ECB then
	    t_raw := encr( substr( t_tmp, i * 16 + 1, 16 ) );
	  when CHAIN_OFB then
	    t_iv := encr( t_iv );
	    t_raw := utl_raw.bit_xor( substr( t_tmp, i * 16 + 1, 16 ), t_iv );
	  else
	    null;
	end case;
	t_tmp2 := t_tmp2 || t_raw;
      end loop;
      t_encr :=	utl_raw.concat(	t_encr,	hextoraw( t_tmp2 ) );
    end	loop;
    return t_encr;
  end;
--
  function decrypt( src	raw, typ pls_integer, key raw, iv raw := null )
  return raw
  is
    t_keys tp_des;
    t_keys2 tp_des;
    t_keys3 tp_des;
    t_idx pls_integer;
    t_len pls_integer;
    t_tmp varchar2(32766);
    t_tmp2 varchar2(32766);
    t_decr raw(32767);
    t_pad pls_integer;
    t_iv raw(8);
    t_raw raw(8);
    function decr( p raw )
    return raw
    is
      tmp raw(100);
    begin
      case bitand( typ,	15 )
	when ENCRYPT_3DES then
	  tmp := des( des( des(	p, t_keys3 ), t_keys2 ), t_keys	);
	when ENCRYPT_DES then
	  tmp := des( p, t_keys	);
	when ENCRYPT_3DES_2KEY then
	  tmp := des( des( des(	p, t_keys3 ), t_keys2 ), t_keys	);
	else
	  tmp := p;
      end case;
      return tmp;
    end;
  begin
    if bitand( typ, 255 ) = ENCRYPT_RC4
    then
      return encrypt_rc4( src, key );
    end if;
    case bitand( typ, 15 )
      when ENCRYPT_3DES	then
	deskey(	utl_raw.substr(	key, 1,	8 ), t_keys, bitand( typ, 3840 ) in ( CHAIN_CFB,CHAIN_OFB ) );
	deskey(	utl_raw.substr(	key, 9,	8 ), t_keys2, bitand( typ, 3840	) not in ( CHAIN_CFB,CHAIN_OFB ) );
	deskey(	utl_raw.substr(	key, 17, 8 ), t_keys3, bitand( typ, 3840 ) in (	CHAIN_CFB,CHAIN_OFB ) );
      when ENCRYPT_DES then
	deskey(	utl_raw.substr(	key, 1,	8 ), t_keys, bitand( typ, 3840 ) in ( CHAIN_CFB,CHAIN_OFB ) );
      when ENCRYPT_3DES_2KEY then
	deskey(	utl_raw.substr(	key, 1,	8 ), t_keys, bitand( typ, 3840 ) in ( CHAIN_CFB,CHAIN_OFB ) );
	deskey(	utl_raw.substr(	key, 9,	8 ), t_keys2, bitand( typ, 3840	) not in ( CHAIN_CFB,CHAIN_OFB ) );
	t_keys3	:= t_keys;
      else
	null;
    end	case;
    t_idx := 1;
    t_len := utl_raw.length( src );
    t_iv := coalesce( iv, utl_raw.copies( '0', 8 ) );
    while t_idx	<= t_len
    loop
      t_tmp := utl_raw.substr( src, t_idx, least( 16376, t_len - t_idx + 1 ) );
      t_idx := t_idx + 16376;
      t_tmp2 :=	null;
      for i in 0 .. length( t_tmp ) / 16 - 1
      loop
	case bitand( typ, 3840 )
	 when CHAIN_CBC	then
	    t_raw := decr( substr( t_tmp, i * 16 + 1, 16 ) );
	    t_raw := utl_raw.bit_xor( t_raw, t_iv );
	    t_iv := substr( t_tmp, i * 16 + 1, 16 );
	  when CHAIN_CFB then
	    t_raw := decr( t_iv	);
	    t_iv := substr( t_tmp, i * 16 + 1, 16 );
	    t_raw := utl_raw.bit_xor( t_raw, t_iv );
	  when CHAIN_OFB then
	    t_iv := decr( t_iv );
	    t_raw := utl_raw.bit_xor( substr( t_tmp, i * 16 + 1, 16 ), t_iv );
	  when CHAIN_ECB then
	    t_raw := decr( substr( t_tmp, i * 16 + 1, 16 ) );
	end case;
	t_tmp2 := t_tmp2 || t_raw;
      end loop;
      t_decr :=	utl_raw.concat(	t_decr,	hextoraw( t_tmp2 ) );
    end	loop;
--dbms_output.put_line(	t_decr );
    case bitand( typ, 61440 )
      when PAD_PKCS5 then
	t_pad := to_number( utl_raw.substr( t_decr, -1 ), 'XX' );
	t_pad := utl_raw.length( t_decr	) - t_pad;
	t_decr := utl_raw.substr( t_decr, 1, t_pad );
      when PAD_OneAndZeroes then -- OneAndZeroes Padding, ISO/IEC 7816-4
	t_pad := length( t_tmp2	) - instr( t_tmp2, '80', -1 ) +	1;
	t_pad := utl_raw.length( t_decr	) - t_pad / 2;
	t_decr := utl_raw.substr( t_decr, 1, t_pad );
      when PAD_ANSI_X923 then -- ANSI X.923
	t_pad := to_number( utl_raw.substr( t_decr, -1 ), 'XX' );
	t_pad := utl_raw.length( t_decr	) - t_pad - 1;
	t_decr := utl_raw.substr( t_decr, 1, t_pad );
      when PAD_ZERO then -- zero padding
	t_pad := length( t_tmp2	) - length( rtrim( t_tmp2, '0' ) );
	t_pad := trunc(	t_pad /	2 );
	if t_pad > 0
	then
	  t_pad	:= utl_raw.length( t_decr ) - t_pad;
	  t_decr := utl_raw.substr( t_decr, 1, t_pad );
	end if;
      when PAD_ORCL then -- zero padding
	t_pad := length( t_tmp2	) - length( rtrim( t_tmp2, '0' ) );
	t_pad := trunc(	t_pad /	2 );
	if t_pad > 0
	then
	  t_pad	:= utl_raw.length( t_decr ) - t_pad;
	  t_decr := utl_raw.substr( t_decr, 1, t_pad );
	end if;
      else
	null;
    end	case;
    return t_decr;
  end;
begin
  t_key	:= utl_raw.cast_to_raw('12345678');
  t_key	:= '8172635445362718';
  t_key	:= '817263544536271801020304050607088070605040302010';
--  t_key := '12345678';
--  dbms_output.put_line( t_key	);
  t_secret := utl_raw.cast_to_raw( 'dit	is 1' );
  t_secret := utl_raw.cast_to_raw( 'dit	is 112345678' );
--  t_secret :=	'0000000000000000B8EA30A3653ABF7B';
  t_iv := '1827364554637281';
--  t_iv := '';
  t_type := ENCRYPT_3DES_2key +	CHAIN_CFB + PAD_NONE;
  t_encr := encrypt( t_secret, t_type, t_key, t_iv );
--  dbms_output.put_line( t_encr );
--  dbms_output.put_line( utl_raw.cast_to_varchar2( desdecrypt(	t_encr,	t_key )	) );
--  dbms_output.put_line( 'sec:	' || t_secret );
--  t_encr := DBMS_OBFUSCATION_TOOLKIT.DESEncrypt( input => t_secret, key => t_key );
--  t_encr := dbms_crypto.encrypt( t_secret, dbms_crypto.ENCRYPT_3DES +	dbms_crypto.CHAIN_CBC +	dbms_crypto.PAD_PKCS5, t_key, t_iv );
--  dbms_output.put_line( 'encr	' || lower( t_encr ) );
  dbms_output.put_line(	'encr '	|| t_encr );
  dbms_output.put_line(	utl_raw.cast_to_varchar2( decrypt( t_encr, t_type, t_key, t_iv ) ) || 'x' );
--  dbms_output.put_line( DBMS_OBFUSCATION_TOOLKIT.DESEncrypt( input =>	t_secret, key => t_key ) );
--  dbms_output.put_line( utl_raw.cast_to_varchar2( DBMS_OBFUSCATION_TOOLKIT.DESDecrypt( input => t_encr, key => t_key ) ) );
--  dbms_output.put_line( DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(	input => t_secret, key => t_key, which => DBMS_OBFUSCATION_TOOLKIT.twokeymode, iv => t_iv ) );
--  dbms_output.put_line( DBMS_OBFUSCATION_TOOLKIT.DES3Encrypt(	input => t_secret, key => t_key, which => DBMS_OBFUSCATION_TOOLKIT.threekeymode, iv => t_iv ) );
/*
6469742069732065656e20746573742e
4421432db2dc3af63f0a3629a058da09
  t_pw := DBMS_OBFUSCATION_TOOLKIT.DESDecrypt( input =>	utl_raw.substr(	t_secret, 1, 16	), key => t_key	);
  dbms_output.put_line(	t_pw );
  dbms_output.put_line(	utl_raw.cast_to_varchar2( t_pw ) );
--
0000000000000000
DES: DES/CBC/PKCS5PADDING c4c903bb59c7dc76aacc99ce1a072397
DES: DES/CFB/PKCS5PADDING dc8344830c499f4acc52e38eeac55a47
DES: DES/OFB/PKCS5PADDING dc8344830c499f4a7449a2440b9bf7a2
DES: DES/ECB/PKCS5PADDING c4c903bb59c7dc76682d669b8e57fccb
--
1827364554637281
DES: DES/CBC/PKCS5PADDING 7b10c69a5bf8838def7fb1c807a5f105
DES: DES/CFB/PKCS5PADDING 5517eb3ccca65c89768a38e49c293d34
DES: DES/OFB/PKCS5PADDING 5517eb3ccca65c897390eccbe068ff80
DES: DES/ECB/PKCS5PADDING c4c903bb59c7dc76682d669b8e57fccb
*/
end;


--
RC2
declare
  t_iv raw(16);
  t_key	raw(32);
  t_secret raw(48);
  t_encr raw(48);
--
  type tp_rc2 is table of number index by pls_integer;
  t_rc2key tp_rc2;
--
  function bitor( x integer, y integer )
  return integer
  is
  begin
    return bitand( x + y - bitand( x, y	), 4294967295 );
  end;
--
  function bitxor( x integer, y	integer	)
  return integer
  is
  begin
    return bitand( x + y - 2 * bitand( x, y ), 4294967295 );
  end;
--
  function shl(	x integer, b pls_integer )
  return integer
  is
  begin
    return bitand( x * case b
			 when 1	 then 2
			 when 2	 then 4
			 when 3	 then 8
			 when 4	 then 16
			 when 5	 then 32
			 when 6	 then 64
			 when 7	 then 128
			 when 8	 then 256
			 when 9	 then 512
			 when 10 then 1024
			 when 11 then 2048
			 when 12 then 4096
			 when 13 then 8192
			 when 14 then 16384
			 when 15 then 32768
			 when 16 then 65536
			 when 24 then 16777216
			 when 28 then 268435456
			 when 31 then 2147483648
		       end
		 , 4294967295
		 );
  end;
--
  function shr(	x integer, b pls_integer )
  return integer
  is
  begin
    return trunc( x / case b
			when 0	then 1
			when 1	then 2
			when 2	then 4
			when 3	then 8
			when 4	then 16
			when 5	then 32
			when 6	then 64
			when 7	then 128
			when 8	then 256
			when 9	then 512
			when 10	then 1024
			when 11	then 2048
			when 12	then 4096
			when 13	then 8192
			when 14	then 16384
			when 15	then 32768
			when 16	then 65536
			when 24	then 16777216
			when 28	then 268435456
		      end );
  end;
--
  function rol16( x integer, b pls_integer )
  return integer
  is
    t integer := bitand( x, 65535 );
  begin
    return bitand( bitor( shl( t, b ), shr( t, 16 - b )	), 65535 );
  end;
--
  function ror16( x integer, b pls_integer )
  return integer
  is
    t integer := bitand( x, 65535 );
  begin
    return bitand( bitor( shr( t, b ), shl( t, 16 - b )	), 65535 );
  end;
--
  procedure init_key( p_key varchar2 )
  is
    t_pi varchar2(512);
    t_len pls_integer;
    t_ksb pls_integer;
    j pls_integer;
    t_tmp tp_rc2;
  begin
    t_pi := 'd978f9c419ddb5ed28e9fd794aa0d89dc67e37832b76538e624c6488448bfba2'
	 || '179a59f587b34f1361456d8d09817d32bd8f40eb86b77b0bf09521225c6b4e82'
	 || '54d66593ce60b21c7356c014a78cf1dc1275ca1f3bbee4d1423dd430a33cb626'
	 || '6fbf0eda4669075727f21d9bbc944303f811c7f690ef3ee706c3d52fc8661ed7'
	 || '08e8eade8052eef784aa72ac354d6a2a961ad2715a1549744b9fd05e0418a4ec'
	 || 'c2e0416e0f51cbcc2491af50a1f47039997c3a8523b8b47afc02365b25559731'
	 || '2d5dfa98e38a92ae05df2910676cbac9d300e6cfe19ea82c6316013f58e289a9'
	 || '0d38341bab33ffb0bb480c5fb9b1cd2ec5f3db47e5a59c770aa62068fe7fc1ad';
    t_len := length( p_key ) / 2;
    for	i in 0 .. t_len	- 1
    loop
      t_tmp( i ) := to_number( substr( p_key, i	* 2 + 1, 2 ), 'xx' );
    end	loop;
    for	i in length( p_key ) / 2 .. 127
    loop
      j	:= bitand( t_tmp( i - 1	) + t_tmp( i - t_len ),	255 );
      t_tmp( i ) := to_number( substr( t_pi, j * 2 + 1,	2 ), 'xx' );
    end	loop;
    t_ksb := trunc( ( t_len * 8	+ 7 ) /	8 );
    j := t_tmp(	128 - t_ksb );
    j := to_number( substr( t_pi, j * 2	+ 1, 2 ), 'xx' );
    t_tmp( 128 - t_ksb ) := bitand( j, shr( 255, t_ksb * 8 - t_len * 8 ) );
    for	i in reverse 0 .. 127 -	t_ksb
    loop
      j	:= bitxor( t_tmp( i + 1	), t_tmp( i + t_ksb ) );
      j	:= to_number( substr( t_pi, j *	2 + 1, 2 ), 'xx' );
      t_tmp( i ) := bitand( j, 255 );
    end	loop;
    for	i in 0 .. 63
    loop
      t_rc2key(	i ) := t_tmp( 2	* i ) +	t_tmp( 2 * i + 1 ) * 256;
    end	loop;
  end;
--
  function rc2encrypt( p_block raw )
  return varchar2
  is
    t_data0 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 1, 2 ), utl_raw.little_endian );
    t_data1 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 3, 2 ), utl_raw.little_endian );
    t_data2 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 5, 2 ), utl_raw.little_endian );
    t_data3 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 7, 2 ), utl_raw.little_endian );
    j pls_integer := 0;
    procedure steps( p1	in out number, p2 pls_integer, p3 number, p4 number, p5	number )
    is
    begin
      p1 := p1 + t_rc2key( j ) + bitand( p3, p4	) + bitand( - p3 - 1, p5 );
      p1 := rol16( p1, p2 );
      j	:= j + 1;
    end;
    procedure mix( c pls_integer )
    is
    begin
      for i in 1 .. c
      loop
	steps( t_data0,	1, t_data3, t_data2, t_data1 );
	steps( t_data1,	2, t_data0, t_data3, t_data2 );
	steps( t_data2,	3, t_data1, t_data0, t_data3 );
	steps( t_data3,	5, t_data2, t_data1, t_data0 );
      end loop;
    end;
    procedure mash
    is
    begin
      t_data0 := bitand( t_data0 + t_rc2key( bitand( t_data3, 63 ) ), 65535 );
      t_data1 := bitand( t_data1 + t_rc2key( bitand( t_data0, 63 ) ), 65535 );
      t_data2 := bitand( t_data2 + t_rc2key( bitand( t_data1, 63 ) ), 65535 );
      t_data3 := bitand( t_data3 + t_rc2key( bitand( t_data2, 63 ) ), 65535 );
    end;
  begin
    mix( 5 );
    mash;
    mix( 6 );
    mash;
    mix( 5 );
    return substr( utl_raw.cast_from_binary_integer( t_data0, utl_raw.little_endian ), 1, 4 )
	|| substr( utl_raw.cast_from_binary_integer( t_data1, utl_raw.little_endian ), 1, 4 )
	|| substr( utl_raw.cast_from_binary_integer( t_data2, utl_raw.little_endian ), 1, 4 )
	|| substr( utl_raw.cast_from_binary_integer( t_data3, utl_raw.little_endian ), 1, 4 );
  end;
--
  function rc2decrypt( p_block raw )
  return varchar2
  is
    t_data0 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 1, 2 ), utl_raw.little_endian );
    t_data1 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 3, 2 ), utl_raw.little_endian );
    t_data2 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 5, 2 ), utl_raw.little_endian );
    t_data3 number := utl_raw.cast_to_binary_integer( utl_raw.substr( p_block, 7, 2 ), utl_raw.little_endian );
    j pls_integer := 63;
procedure p( m varchar2	)
is
begin
  dbms_output.put_line(	lower( substr( utl_raw.cast_from_binary_integer( t_data0 ), 5, 4 )
		     ||	substr(	utl_raw.cast_from_binary_integer( t_data1 ), 5,	4 )
		     ||	substr(	utl_raw.cast_from_binary_integer( t_data2 ), 5,	4 )
		     ||	substr(	utl_raw.cast_from_binary_integer( t_data3 ), 5,	4 ) )
		     ||	' ' || m );
end;
    procedure steps( p1	in out number, p2 pls_integer, p3 number, p4 number, p5	number )
    is
    begin
      p1 := ror16( p1, p2 );
      p1 := p1 - t_rc2key( j ) - bitand( p3, p4	) - bitand( - p3 - 1, p5 );
      j	:= j - 1;
    end;
    procedure demix( c pls_integer )
    is
    begin
      for i in 1 .. c
      loop
	steps( t_data3,	5, t_data2, t_data1, t_data0 );
	steps( t_data2,	3, t_data1, t_data0, t_data3 );
	steps( t_data1,	2, t_data0, t_data3, t_data2 );
	steps( t_data0,	1, t_data3, t_data2, t_data1 );
      end loop;
    end;
    procedure demash
    is
    begin
      t_data3 := bitand( t_data3 - t_rc2key( bitand( t_data2, 63 ) ), 65535 );
      t_data2 := bitand( t_data2 - t_rc2key( bitand( t_data1, 63 ) ), 65535 );
      t_data1 := bitand( t_data1 - t_rc2key( bitand( t_data0, 63 ) ), 65535 );
      t_data0 := bitand( t_data0 - t_rc2key( bitand( t_data3, 63 ) ), 65535 );
    end;
  begin
    demix( 5 );
    demash;
    demix( 6 );
    demash;
    demix( 5 );
    return substr( utl_raw.cast_from_binary_integer( t_data0, utl_raw.little_endian ), 1, 4 )
	|| substr( utl_raw.cast_from_binary_integer( t_data1, utl_raw.little_endian ), 1, 4 )
	|| substr( utl_raw.cast_from_binary_integer( t_data2, utl_raw.little_endian ), 1, 4 )
	|| substr( utl_raw.cast_from_binary_integer( t_data3, utl_raw.little_endian ), 1, 4 );
  end;
begin
  t_key	:= '1827364554637281';
  t_secret := utl_raw.cast_to_raw( 'dit	is 1' );
  init_key( t_key );
  t_encr := rc2encrypt(	t_secret );
  dbms_output.put_line(	lower( t_encr )	);
  dbms_output.put_line(	utl_raw.cast_to_varchar2( rc2decrypt( t_encr ) ) );
end;

declare
  bmax32 constant number := power( 2, 32 ) - 1;
  bmax64 constant number := power( 2, 64 ) - 1;
  type tp_crypto is table of number;
--
  cast_kr tp_crypto;
  cast_km tp_crypto;
  type tp_cast_sbox is table of	number index by	varchar2(2);
  S1 tp_cast_sbox;
  S2 tp_cast_sbox;
  S3 tp_cast_sbox;
  S4 tp_cast_sbox;
--
  t_key	raw(32767);
  t_encr raw(32767);
--
  function bitor( x number, y number )
  return number
  is
  begin
    return x + y - bitand( x, y	);
  end;
--
  function bitxor( x number, y number )
  return number
  is
  begin
    return x + y - 2 * bitand( x, y );
  end;
--
  function shl(	x number, b pls_integer	)
  return number
  is
  begin
    return x * power( 2, b );
  end;
--
  function shr(	x number, b pls_integer	)
  return number
  is
  begin
    return trunc( x / power( 2,	b ) );
  end;
--
  function rol32( x number, b pls_integer )
  return number
  is
    t number;
  begin
    t := bitand( x, bmax32 );
    return bitand( bitor( shl( t, b ), shr( t, 32 - b )	), bmax32 );
  end;
--
  procedure cast_key( key raw
		    , km in out	nocopy tp_crypto
		    , kr in out	nocopy tp_crypto
		    )
  is
    x varchar2(40);
    z varchar2(40);
    S5 tp_cast_sbox;
    S6 tp_cast_sbox;
    S7 tp_cast_sbox;
    S8 tp_cast_sbox;
--
    procedure fill_sbox( p_data	varchar2, p_box	in out nocopy tp_cast_sbox )
    is
    begin
      for i in 0 .. 255
      loop
	p_box( to_char(	i, 'fm0X' ) ) := to_number( substr( p_data, i *	8 + 1, 8 ), 'xxxxxxxx' );
      end loop;
    end;
--
    function gsb( Sb tp_cast_sbox, p pls_integer )
    return number
    is
    begin
      if p > 0
      then
	return Sb( substr( x, p, 2 ) );
      end if;
      return Sb( substr( z, -p,	2 ) );
    end;
--
    function subkey2( p2 pls_integer, p3 pls_integer, p4 pls_integer, p5 pls_integer, p6 pls_integer, s	pls_integer )
    return number
    is
      t2 number;
      t3 number;
      t4 number;
      t5 number;
      t6 number;
    begin
      t2 := gsb( S5, p2	);
      t3 := gsb( S6, p3	);
      t4 := gsb( S7, p4	);
      t5 := gsb( S8, p5	);
      t6 := gsb( case s
		   when	1 then S7
		   when	2 then S8
		   when	3 then S5
		   when	4 then S6
		 end
	       , p6 );
      return bitxor( t2, bitxor( t3, bitxor( t4, bitxor( t5, t6	) ) ) );
    end;
--
    function subkey( p1	pls_integer, p2	pls_integer, p3	pls_integer, p4	pls_integer, p5	pls_integer, p6	pls_integer, s pls_integer )
    return varchar2
    is
      t1 number;
    begin
      if p1 > 0
      then
	t1 := to_number( substr( x, p1,	8 ), 'xxxxxxxx'	);
      else
	t1 := to_number( substr( z, -p1, 8 ), 'xxxxxxxx' );
      end if;
      return substr( to_char( bitxor( t1, subkey2( p2, p3, p4, p5, p6, s ) )
			    , '0XXXXXXXXX' ), -8 );
    end;
--
    procedure fill_subkey( k in	out nocopy tp_crypto )
    is
    begin
      k	:= tp_crypto();
      k.extend(	16 );
      z	:= subkey( 1, 27, 31, 25, 29, 17, 1 );
      z	:= z ||	subkey(	17, -1,	-5, -3,	-7, 21,	2 );
      z	:= z ||	subkey(	25, -15, -13, -11, -9, 19, 3 );
      z	:= z ||	subkey(	9, -21,	-19, -23, -17, 23, 4 );
      x	:= subkey( -17,	-11, -15, -9, -13, -1, 1 );
      x	:= x ||	subkey(	-1, 1, 5, 3, 7,	-5, 2 );
      x	:= x ||	subkey(	-9, 15,	13, 11,	9, -3, 3 );
      x	:= x ||	subkey(	-25, 21, 19, 23, 17, -7, 4 );
      k(1) := subkey2( -17, -19, -15, -13, -5, 3 );
      k(2) := subkey2( -21, -23, -11, -9, -13, 4 );
      k(3) := subkey2( -25, -27, -7, -5, -19, 1	);
      k(4) := subkey2( -29, -31, -3, -1, -25, 2	);
      k(5) := subkey2( 7, 5, 25, 27, 17, 3 );
      k(6) := subkey2( 3, 1, 29, 31, 27, 4 );
      k(7) := subkey2( 15, 13, 17, 19, 7, 1 );
      k(8) := subkey2( 11, 9, 21, 23, 15, 2 );
      z	:= subkey( 1, 27, 31, 25, 29, 17, 1 );
      z	:= z ||	subkey(	17, -1,	-5, -3,	-7, 21,	2 );
      z	:= z ||	subkey(	25, -15, -13, -11, -9, 19, 3 );
      z	:= z ||	subkey(	9, -21,	-19, -23, -17, 23, 4 );
      x	:= subkey( -17,	-11, -15, -9, -13, -1, 1 );
      x	:= x ||	subkey(	-1, 1, 5, 3, 7,	-5, 2 );
      x	:= x ||	subkey(	-9, 15,	13, 11,	9, -3, 3 );
      x	:= x ||	subkey(	-25, 21, 19, 23, 17, -7, 4 );
      k(9) := subkey2( -7, -5, -25, -27, -19, 3	);
      k(10) := subkey2(	-3, -1,	-29, -31, -25, 4 );
      k(11) := subkey2(	-15, -13, -17, -19, -5,	1 );
      k(12) := subkey2(	-11, -9, -21, -23, -13,	2 );
      k(13) := subkey2(	17, 19,	15, 13,	7, 3 );
      k(14) := subkey2(	21, 23,	11, 9, 15, 4 );
      k(15) := subkey2(	25, 27,	7, 5, 17, 1 );
      k(16) := subkey2(	29, 31,	3, 1, 27, 2 );
    end;
  begin
    fill_sbox( '30fb40d49fa0ff0b6beccd2f3f258c7a1e213f2f9c004dd36003e540cf9fc949'
	    || 'bfd4af2788bbbdb5e203409098d096756e63a0e015c361d2c2e7661d22d4ff8e'
	    || '28683b6fc07fd059ff2379c8775f50e243c340d3df2f8656887ca41aa2d2bd2d'
	    || 'a1c9e0d6346c481961b76d8722540f2f2abe32e1aa54166b22568e3aa2d341d0'
	    || '66db40c8a784392f004dff2f2db9d2de97943fac4a97c1d8527644b7b5f437a7'
	    || 'b82cbaefd751d1596ff7f0ed5a097a1f827b68d090ecf52e22b0c054bc8e5935'
	    || '4b6d2f7f50bb64a2d2664910bee5812db7332290e93b159fb48ee4114bff345d'
	    || 'fd45c240ad31973fc4f6d02e55fc8165d5b1caada1ac2daea2d4b76dc19b0c50'
	    || '882240f20c6e4f38a4e4bfd74f5ba272564c1d2fc59c5319b949e354b04669fe'
	    || 'b1b6ab8ac71358dd6385c545110f935d57538ad56a390493e63d37e02a54f6b3'
	    || '3a787d5f6276a0b519a6fcdf7a42206a29f9d4d5f61b1891bb72275eaa508167'
	    || '38901091c6b505eb84c7cb8c2ad75a0f874a1427a2d1936b2ad286afaa56d291'
	    || 'd7894360425c750d93b39e26187184c96c00b32d73e2bb14a0bebc3c54623779'
	    || '64459eab3f328b827718cf8259a2cea604ee002e89fe78e63fab0950325ff6c2'
	    || '81383f056963c5c876cb5ad6d49974c9ca180dcf380782d5c7fa5cf68ac31511'
	    || '35e79e1347da91d0f40f9086a7e2419e31366241051ef495aa573b044a805d8d'
	    || '548300d000322a3cbf64cddfba57a68e75c6372b50afd341a7c13275915a0bf5'
	    || '6b54bfab2b0b1426ab4cc9d7449ccd82f7fbf265ab85c5f31b55db94aad4e324'
	    || 'cfa4bd3f2deaa3e29e204d02c8bd25aceadf55b3d5bd9e98e31231b22ad5ad6c'
	    || '954329deadbe4528d8710f69aa51c90faa786bf622513f1eaa51a79b2ad344cc'
	    || '7b5a41f0d37cfbad1b06950541ece491b4c332e6032268d4c9600accce387e6d'
	    || 'bf6bb16c6a70fb780d03d9c9d4df39dee01063da4736f4645ad328d8b347cc96'
	    || '75bb0fc398511bfb4ffbcc35b58bcf6ae11f0abcbfc5fe4aa70aec10ac39570a'
	    || '3f04442f6188b153e0397a2e5727cb799ceb418f1cacd68d2ad37c960175cb9d'
	    || 'c69dff09c75b65f0d9db40d8ec0e77794744ead4b11c3274dd24cb9e7e1c54bd'
	    || 'f01144f9d2240eb19675b3fda3ac3755d47c27af51c85f4d56907596a5bb15e6'
	    || '580304f0ca042cf1011a37ea8dbfaadb35ba3e4a3526ffa0c37b4d09bc306ed9'
	    || '98a526665648f725ff5e569d0ced63d07c63b2cf700b45e1d5ea50f185a92872'
	    || 'af1fbda7d4234870a7870bf32d3b4d7942e041980cd0ede726470db8f881814c'
	    || '474d6ad77c0c5e5cd1231959381b7298f5d2f4dbab8386536e2f1e2383719c9e'
	    || 'bd91e0469a56456edc39200c20c8c571962bda1ce1e696ffb141ab087cca89b9'
	    || '1a69e78302cc4843a2f7c579429ef47d427b169c5ac9f049dd8f0f005c8165bf'
	    , S1
	    );
    fill_sbox( '1f201094ef0ba75b69e3cf7e393f4380fe61cf7aeec5207a55889c9472fc0651'
	    || 'ada7ef794e1d7235d55a63cede0436ba99c430ef5f0c079418dcdb7da1d6eff3'
	    || 'a0b52f7b59e83605ee15b094e9ffd909dc440086ef944459ba83ccb3e0c3cdfb'
	    || 'd1da41813b092ab1f997f1c1a5e6cf7b01420ddbe4e7ef5b25a1ff41e180f806'
	    || '1fc41080179bee7ad37ac6a9fe5830a498de8b7f77e83f4e7992926924fa9f7b'
	    || 'e113c85bacc40083d7503525f7ea615f621431540d554b635d681121c866c359'
	    || '3d63cf73cee234c0d4d87e875c672b21071f618139f7627f361e3084e4eb573b'
	    || '602f64a4d63acd9c1bbc46359e81032d2701f50c99847ab4a0e3df79ba6cf38c'
	    || '108430942537a95ef46f6ffea1ff3b1f208cfb6a8f458c74d9e0a2274ec73a34'
	    || 'fc884f693e4de8dfef0e00883559648d8a45388c1d804366721d9bfda58684bb'
	    || 'e8256333844e8212128d8098fed33fb4ce280ae127e19ba5d5a6c252e49754bd'
	    || 'c5d655ddeb66706477840b4da1b6a80184db26a9e0b5671421f043b7e5d05860'
	    || '54f03084066ff472a31aa153dadc4755b5625dbf68561be683ca6b942d6ed23b'
	    || 'eccf01dba6d3d0bab6803d5caf77a70933b4a34c397bc8d65ee22b955f0e5304'
	    || '81ed6f6120e74364b45e1378de18639b881ca122b96726d18049a7e822b7da7b'
	    || '5e552d255272d23779d2951cc60d894c488cb4021ba4fe5ba4b09f6b1ca815cf'
	    || 'a20c30058871df63b9de2fcb0cc6c9e90beeff53e3214517b45428359f63293c'
	    || 'ee41e7296e1d2d7c500452861e6685f3f33401c630a22c9531a7085060930f13'
	    || '73f98417a1269859ec645c4452c877a9cdff33a6a02b17417cbad9a22180036f'
	    || '50d99c08cb3f4861c26bd76564a3f6ab8034267625a75e7be4e6d1fc20c710e6'
	    || 'cdf0b68017844d3b31eef84d7e0824e42ccb49eb846a3bae8ff77888ee5d60f6'
	    || '7af756732fdd5cdba11631c130f66f43b3faec54157fd7faef8579ccd152de58'
	    || 'db2ffd5e8f32ce19306af97a02f03ef899319ad5c242fa0fa7e3ebb0c68e4906'
	    || 'b8da230c80823028dcdef3c8d35fb171088a1bc8bec0c56061a3c9e8bca8f54d'
	    || 'c72feffa22822e9982c570b4d8d94e898b1c34bc301e16e6273be979b0ffeaa6'
	    || '61d9b8c600b24869b7ffce3f08dc283b43daf65af7e197987619b72f8f1c9ba4'
	    || 'dc8637a016a7d3b19fc393b7a7136eebc6bcc63e1a513742ef6828bc520365d6'
	    || '2d6a77ab3527ed4b821fd216095c6e2edb92f2fb5eea29cb145892f591584f7f'
	    || '5483697b2667a8cc851960488c4bacea833860d40d23e0f96c387e8a0ae6d249'
	    || 'b284600cd835731ddcb1c647ac4c56ea3ebd81b3230eabb06438bc87f0b5b1fa'
	    || '8f5ea2b3fc1846420a036b7a4fb089bd649da589a345415e5c0383233e5d3bb9'
	    || '43d795727e6dd07c06dfdf1e6c6cc4ef7160a53973bfbe70838776054523ecf1'
	    , S2
	    );
    fill_sbox( '8defc24025fa5d9feb903dbfe810c90747607fff369fe44b8c1fc644aececa90'
	    || 'beb1f9bfeefbcaeae8cf195051df07ae920e8806f0ad0548e13c8d83927010d5'
	    || '11107d9f07647db9b2e3e4d43d4f285eb9afa820fade82e0a067268b8272792e'
	    || '553fb2c0489ae22bd4ef9794125e3fbc21fffcee825b1bfd9255c5ed1257a240'
	    || '4e1a8302bae07fff528246e78e57140e3373f7bf8c9f8188a6fc4ee8c982b5a5'
	    || 'a8c01db7579fc26467094f31f2bd3f5f40fff7c11fb78dfc8e6bd2c1437be59b'
	    || '99b03dbfb5dbc64b638dc0e655819d99a197c81c4a012d6ec5884a28ccc36f71'
	    || 'b843c2136c0743f18309893c0feddd5f2f7fe850d7c07f7e02507fbf5afb9a04'
	    || 'a747d2d01651192eaf70bf3e58c313805f98302e727cc3c40a0fb4020f7fef82'
	    || '8c96fdad5d2c2aae8ee99a4950da88b88427f4a01eac5790796fb4498252dc15'
	    || 'efbd7d9ba672597dada840d845f54504fa5d7403e83ec3054f91751a925669c2'
	    || '23efe941a903f12e60270df20276e4b694fd6574927985b28276dbcb02778176'
	    || 'f8af918d4e48f79e8f616ddfe29d840e842f7d83340ce5c896bbb68293b4b148'
	    || 'ef303cab984faf28779faf9b92dc560d224d1e208437aa887d29dc962756d3dc'
	    || '8b907ceeb51fd240e7c07ce3e566b4a1c3e9615e3cf8209d6094d1e3cd9ca341'
	    || '5c76460e00ea983bd4d67881fd47572cf76cedd9bda8229c127dadaa438a074e'
	    || '1f97c090081bdb8a93a07ebeb938ca1597b03cff3dc2c0f88d1ab2ec64380e51'
	    || '68cc7bfbd90f2788124901815de5ffd4dd7ef86a76a2e214b9a40368925d958f'
	    || '4b39fffaba39aee9a4ffd30bfaf7933b6d498623193cbcfa27627545825cf47a'
	    || '61bd8ba0d11e42d1cead04f4127ea39210428db78272a9729270c4a8127de50b'
	    || '285ba1c83c62f44f35c0eaa5e805d231428929fbb4fcdf824fb66a530e7dc15b'
	    || '1f081fab108618aefcfd086df9ff2889694bcc11236a5cae12deca4d2c3f8cc5'
	    || 'd2d02dfef8ef5896e4cf52da95155b67494a488cb9b6a80c5c8f82bc89d36b45'
	    || '3a609437ec00c9a9447152530a874b49d773bc407c34671c02717ef64feb5536'
	    || 'a2d02fffd2bf60c4d43f03c050b4ef6d07478cd1006e1888a2e53f55b9e6d4bc'
	    || 'a204801697573833d7207d67de0f8f3d72f87b33abcc4f337688c55d7b00a6b0'
	    || '947b0001570075d2f9bb88f88942019e4264a5ff856302e072dbd92bee971b69'
	    || '6ea22fde5f08ae2baf7a616de5c98767cf1febd261efc8c2f1ac2571cc8239c2'
	    || '67214cb8b1e583d1b7dc3e627f10bdcef90a5c380ff0443d606e6dc660543a49'
	    || '5727c1482be98a1d8ab4173820e1be24af96da0f6845842599833be5600d457d'
	    || '282f93508334b362d91d11202b6d8da0642b1e319c305a0052bce6881b03588a'
	    || 'f7baefd54142ed9ca4315c1183323ec5dfef4636a133c501e9d3531cee353783'
	    , S3
	    );
    fill_sbox( '9db304201fb6e9dea7be7befd273a2984a4f7bdb64ad8c5785510443fa020ed1'
	    || '7e287affe60fb663095f35a179ebf120fd059d436497b7b1f3641f63241e4adf'
	    || '28147f5f4fa2b8cdc94300400cc32220fdd30b30c0a5374f1d2d00d924147b15'
	    || 'ee4d111a0fca516771ff904c2d195ffe1a05645f0c13fefe081b08ca05170121'
	    || '80530100e83e5efeac9af4f87fe72701d2b8ee5f06df4261bb9e9b8a7293ea25'
	    || 'ce84ffdff57188013dd64b04a26f263b7ed48400547eebe6446d4ca06cf3d6f5'
	    || '2649abdfaea0c7f536338cc1503f7e93d377206111b638e172500e03f80eb2bb'
	    || 'abe0502eec8d77de57971e81e14f6746c93354006920318f081dbb99ffc304a5'
	    || '4d3518057f3d5ce3a6c866c65d5bcca9daec6fea9f926f919f46222f3991467d'
	    || 'a5bf6d8e1143c44f43958302d0214eeb022083b83fb6180c18f8931e281658e6'
	    || '26486e3e8bd78a707477e4c1b506e07cf32d0a2579098b02e4eabb8128123b23'
	    || '69dead381574ca16df871b62211c40b7a51a9ef90014377b041e8ac809114003'
	    || 'bd59e4d2e3d156d54fe876d52f91a340557be8de00eae4a70ce5c2ec4db4bba6'
	    || 'e756bdffdd3369acec17b0350657232799afc8b056c8c3916b65811c5e146119'
	    || '6e85cb75be07c002c2325577893ff4ec5bbfc92dd0ec3b25b7801ab78d6d3b24'
	    || '20c763efc366a5fc9c3828800ace3205aac9548aeca1d7c7041afa321d16625a'
	    || '6701902c9b757a5431d477f79126b03136cc6fdbc70b8b46d9e66a4856e55a79'
	    || '026a4ceb52437eff2f8f76b40df980a58674cde3edda04eb17a9be042c18f4df'
	    || 'b7747f9dab2af7b4efc34d202e096b7c1741a254e5b6a035213d42f62c1c7c26'
	    || '61c2f50f6552daf9d2c231f825130f69d8167fa20418f2c8001a96a60d1526ab'
	    || '63315c215e0a72ec49bafefd187908d98d0dbd86311170a73e9b640ccc3e10d7'
	    || 'd5cad3b60caec388f73001e16c728aff71eae2a11f9af36ecfcbd12fc1de8417'
	    || 'ac07be6bcb44a1d88b9b0f56013988c3b1c52fcab4be31cdd878280612a3a4e2'
	    || '6f7de53258fd7eb6d01ee90024adffc2f4990fc59711aac5001d7b9582e5e7d2'
	    || '109873f600613096c32d9521ada121ff299084157fbb977faf9eb3db29c9ed2a'
	    || '5ce2a465a730f32cd0aa3fe88a5cc091d49e2ce70ce454a9d60acd86015f1919'
	    || '77079103dea03af678a8565edee356df21f05cbe8b75e387b3c50651b8a5c3ef'
	    || 'd8eeb6d2e523be77c21545292f69efdfafe67afbf470c4b2f3e0eb5bd6cc9876'
	    || '39e4460c1fda85381987832fca007367a99144f8296b299e492fc2959266beab'
	    || 'b5676e699bd3dddadf7e052fdb25701c1b5e51eef65324e66afce36c0316cc04'
	    || '8644213eb7dc59d07965291fccd6fd4341823979932bcdf6b657c34d4edfd282'
	    || '7ae5290c3cb9536b851e20fe9833557e13ecf0b0d3ffb3723f85c5c10aef7ed2'
	    , S4
	    );
    fill_sbox( '7ec90c042c6e74b99b0e66dfa6337911b86a7fff1dd358f544dd9d441731167f'
	    || '08fbf1fae7f511ccd2051b00735aba002ab722d8386381cbacf6243a69befd7a'
	    || 'e6a2e77ff0c720cdc4494816ccf5c1803885164015b0a848e68b18cb4caadeff'
	    || '5f480a010412b2aa259814fc41d0efe24e40b48d248eb6fb8dba1cfe41a99b02'
	    || '1a550a04ba8f65cb7251f4e795a51725c106ecd797a5980ac539b9aa4d79fe6a'
	    || 'f2f3f76368af8040ed0c9e5611b4958be1eb5a888709e6b0d7e071564e29fea7'
	    || '6366e52d02d1c000c4ac8e059377f5710c05372a578535f22261be02d642a0c9'
	    || 'df13a28074b55bd2682199c0d421e5ec53fb3ce8c8adedb328a87fc93d959981'
	    || '5c1ff900fe38d3990c4eff0b062407eaaa2f4fb14fb9697690c79505b0a8a774'
	    || 'ef55a1ffe59ca2c2a6b62d27e66a4263df65001f0ec50966dfdd55bc29de0655'
	    || '911e739a17af897532c7911c89f894680d01e980524755f403b63cc90cc844b2'
	    || 'bcf3f0aa87ac36e9e53a742601b3d82b1a9e744964ee2d7ecddbb1da01c94910'
	    || 'b868bf800d26f3fd9342ede704a5c284636737b650f5b616f24766e38eca36c1'
	    || '136e05dbfef18391fb887a37d6e7f7d4c7fb7dc93063fcdfb6f589deec2941da'
	    || '26e46695b7566419f654efc5d08d58b748925401c1bacb7fe5ff550fb6083049'
	    || '5bb5d0e887d72e5aab6a6ee1223a66cec62bf3cd9e0885f968cb3e47086c010f'
	    || 'a21de820d18b69def3f65777fa02c3f6407edac3cbb3d5501793084db0d70eba'
	    || '0ab378d5d951fb0cded7da564124bbe494ca0b560f5755d1e0e1e56e6184b5be'
	    || '580a249f94f74bc0e327888e9f7b5561c3dc028005687715646c6bd744904db3'
	    || '66b4f0a3c0f1648a697ed5af49e92ff6309e374f2cb6356a858085734991f840'
	    || '76f0ae02083be84d28421c9a44489406736e4cb8c10929108bc95fc67d869cf4'
	    || '134f616f2e77118db31b2be1aa90b4723ca5d7177d161bba9cad9010af462ba2'
	    || '9fe459d245d34559d9f2da13dbc65487f3e4f94e176d486f097c13ea631da5c7'
	    || '445f7382175683f4cdc66a9770be0288b3cdcf726e5dd2f320936079459b80a5'
	    || 'be60e2dba9c23101eba5315c224e42f21c5c1572f6721b2c1ad2fff38c25404e'
	    || '324ed72f4067b7fd0523138e5ca3bc78dc0fd66e75922283784d6b1758ebb16e'
	    || '44094f853f481d87fcfeae7b77b5ff768c2302bfaaf475565f46b02a2b092801'
	    || '3d38f5f70ca81f3652af4a8a66d5e7c0df3b0874950551101b5ad7a8f61ed5ad'
	    || '6cf6e47920758184d0cefa6588f7be584a0468260ff6f8f3a09c7f705346aba0'
	    || '5ce96c28e176eda36bac307f376829d285360fa917e3fe2a24b79767f5a96b20'
	    || 'd6cd259568ff1ebf7555442cf19f06bef9e0659aeeb9491d34010718bb30cab8'
	    || 'e822fe1588570983750e6249da627e555e76ffa8b15345466d47de08efe9e7d4'
	    , S5
	    );
    fill_sbox( 'f6fa8f9d2cac6ce14ca34867e2337f7c95db08e7016843b4eced5cbc325553ac'
	    || 'bf9f0960dfa1e2ed83f0579d63ed86b91ab6a6b8de5ebe39f38ff7328989b138'
	    || '33f14961c01937bdf506c6dae4625e7ea308ea994e23e33c79cbd7cc48a14367'
	    || 'a3149619fec94bd5a114174aeaa01866a084db2d09a8486fa888614a2900af98'
	    || '01665991e1992863c8f30c602e78ef3cd0d51932cf0fec14f7ca07d2d0a82072'
	    || 'fd41197e9305a6b0e86be3da74bed3cd372da53c4c7f4448dab5d4406dba0ec3'
	    || '083919a79fbaeed949dbcfb04e670c535c3d9c0164bdb9412c0e636aba7dd9cd'
	    || 'ea6f7388e70bc76235f29adb5c4cdd8df0d48d8cb88153e208a198661ae2eac8'
	    || '284caf89aa9282239334be533b3a21bf16434be39aea3906efe8c36ef890cdd9'
	    || '80226daec340a4a3df7e9c09a694a8075b7c5ecc221db3a69a69a02f68818a54'
	    || 'ceb2296f53c0843afe89365525bfe68ab4628abccf222ebf25ac6f48a9a99387'
	    || '53bddb65e76ffbe7e967fd780ba935638e342bc1e8a11be94980740dc8087dfc'
	    || '8de4bf99a11101a07fd37975da5a26c0e81f994f9528cd89fd339fedb87834bf'
	    || '5f04456d22258698c9c4c83b2dc156be4f628daa57f55ec5e2220abed2916ebf'
	    || '4ec75b9524f2c3c042d15d99cd0d7fa07b6e27ffa8dc8af07345c106f41e232f'
	    || '35162386e6ea89263333b094157ec6f2372b74af692573e4e9a9d848f3160289'
	    || '3a62ef1da787e238f3a5f67674364853209510634576698db6fad407592af950'
	    || '36f735234cfb6e877da4cec06c152daacb0396a8c50dfe5dfcd707ab0921c42f'
	    || '89dff0bb5fe2be78448f4f33754613c92b05d08d48b9d585dc049441c8098f9b'
	    || '7dede786c39a3373424100056a0917510ef3c8a6890072d628207682a9a9f7be'
	    || 'bf32679dd45b5b75b353fd00cbb0e358830f220a1f8fb214d372cf08cc3c4a13'
	    || '8cf63166061c87be88c98f886062e39747cf8e7ab6c852833cc2acfb3fc06976'
	    || '4e8f025264d8314dda3870e31e665459c10908f0513021a56c5b68b7822f8aa0'
	    || '3007cd3e74719eefdc872681073340d47e432fd90c5ec2418809286cf592d891'
	    || '08a930f6957ef305b7fbffbdc266e96f6fe4ac98b173ecc0bc60b42a953498da'
	    || 'fba1ae122d4bd7360f25faaba4f3fcebe2969123257f0c3d9348af49361400bc'
	    || 'e8816f4a3814f200a3f940439c7a54c2bc704f57da41e7f9c25ad33a54f4a084'
	    || 'b17f550559357cbeedbd15c87f97c5abba5ac7b5b6f6deaf3a479c3a5302da25'
	    || '653d7e6a54268d4951a477ea5017d55bd7d25d8844136c760404a8c8b8e5a121'
	    || 'b81a928a60ed586997c55b96eaec991b2993591301fdb7f1088e8dfa9ab6f6f5'
	    || '3b4cbf9f4a5de3abe6051d35a0e1d855d36b4cf1f544edebb0e93524bebb8fbd'
	    || 'a2d762cf49c92f5438b5f3317128a45448392905a65b1db8851c97bdd675cf2f'
	    , S6
	    );
    fill_sbox( '85e04019332bf567662dbfffcfc656932a8d7f6fab9bc912de6008a12028da1f'
	    || '0227bce74d64291618fac30050f18b822cb2cb11b232e75c4b3695f2b28707de'
	    || 'a05fbcf6cd4181e9e150210ce24ef1bdb168c381fde4e7895c79b0d81e8bfd43'
	    || '4d49500138be4341913cee1d92a79c3f089766bebaeeadf41286becfb6eacb19'
	    || '2660c2007565bde464241f7a8248dca9c3b3ad66281360860bd8dfa8356d1cf2'
	    || '107789beb3b2e9ce0502aa8f0bc0351e166bf52aeb12ff82e3486911d34d7516'
	    || '4e7b3aff5f43671b9cf6e0374981ac83334266ce8c9341b7d0d854c0cb3a6c88'
	    || '47bc28294725ba37a66ad22b7ad61f1e0c5cbafa4437f107b6e7996242d2d816'
	    || '0a961288e1a5c06e13749e6772fc081ab1d139f7f9583745cf19df58bec3f756'
	    || 'c06eba3007211b2445c28829c95e317fbc8ec51138bc46e9c6e6fa14bae8584a'
	    || 'ad4ebc46468f508b7829435ff124183b821dba9faff60ff4ea2c4e6d16e39264'
	    || '92544a8b009b4fc3aba68ced9ac96f7806a5b79ab2856e6e1aec3ca9be838688'
	    || '0e0804e955f1be56e7e5363bb3a1f25df7debb8561fe033c167462333c034c28'
	    || 'da6d0c7479aac56c3ce4e1ad51f0c80298f8f35a1626a49feed82b291d382fe3'
	    || '0c4fb99abb3257783ec6d97b6e77a6a9cb658b5cd45230c72bd1408b60c03eb7'
	    || 'b9068d78a33754f4f430c87dc8a71302b96d8c32ebd4e7bebe8b9d2d7979fb06'
	    || 'e72253088b75cf7711ef8da4e083c8588d6b786f5a6317a6fa5cf7a05dda0033'
	    || 'f28ebfb0f5b9c310a0eac28008b9767aa3d9d2b079d34217021a718d9ac6336a'
	    || '2711fd60438050e3069908a83d7fedc4826d2bef4eeb8476488dcf2536c9d566'
	    || '28e74e41c2610aca3d49a9cfbae3b9dfb65f8de692aeaf643ac7d5e69ea80509'
	    || 'f22b017da4173f70dd1e16c315e0d7f950b1b8872b9f4fd5625aba826a017962'
	    || '2ec01b9c15488aa9d716e74040055a2c93d29a22e32dbf9a058745b93453dc1e'
	    || 'd699296e496cff6f1c9f4986dfe2ed07b87242d119de7eae053e561a15ad6f8c'
	    || '66626c1c7154c24cea082b2a93eb293917dcb0f058d4f2ae9ea294fb52cf564c'
	    || '9883fe662ec40581763953c301d6692ed3a0c108a1e7160ee4f2dfa6693ed285'
	    || '749046984c2b0edd4f7576565d393378a132234f3d321c5dc3f5e1944b269301'
	    || 'c79f022f3c997e7e5e4f95043ffafbbd76f7ad0e296693f43d1fce6fc61e45be'
	    || 'd3b5ab34f72bf9b71b0434c04e72b5675592a33db5229301cfd2a87f60aeb767'
	    || '1814386b30bcc33d38a0c07dfd1606f2c363519b589dd3905479f8e61cb8d647'
	    || '97fd61a9ea7759f42d57539d569a58cfe84e63ad462e1b786580f87ef3817914'
	    || '91da55f440a230f3d1988f35b6e318d23ffa50bc3d40f021c3c0bdae4958c24c'
	    || '518f36b284b1d3700fedce83878ddadaf2a279c794e01be890716f4b954b8aa3'
	    , S7
	    );
    fill_sbox( 'e216300dbbddfffca7ebdabd356480957789f8b7e6c1121b0e241600052ce8b5'
	    || '11a9cfb0e5952f11ece7990a9386d1742a42931c76e38111b12def3a37ddddfc'
	    || 'de9adeb10a0cc32cbe19702984a00940bb243a0fb4d137cfb44e79f0049eedfd'
	    || '0b15a15d480d31688bbbde5a669ded42c7ece8313f8f95e772df191b7580330d'
	    || '940742515c7dcdfaabbe6d63aa402164b301d40a02e7d1ca53571dae7a3182a2'
	    || '12a8ddecfdaa335d176f43e871fb46d438129022ce949ad4b84769ad965bd862'
	    || '82f3d05566fb976715b80b4e1d5b47a04cfde06fc28ec4b857e8726e647a78fc'
	    || '99865d44608bd5936c200e0339dc5ff65d0b00a3ae63aff27e8bd63270108c0c'
	    || 'bbd350492998df04980cf42a9b6df4919e7edd530691854858cb7e073b74ef2e'
	    || '522fffb1d24708cc1c7e27cda4eb215b3cf1d2e219b47a38424f761835856039'
	    || '9d17dee727eb35e6c9aff67b36baf5b809c467cdc18910b1e11dbf7b06cd1af8'
	    || '7170c6082d5e3354d4de495a64c6d006bcc0c62c3dd00db3708f8f3477d51b42'
	    || '264f620f24b8d2bf15c1b79e46a52564f8d7e54e3e3781607895cda5859c15a5'
	    || 'e6459788c37bc75fdb07ba0c0676a3ab7f229b1e31842e7b24259fd7f8bef472'
	    || '835ffcb86df4c1f296f5b195fd0af0fcb0fe134ce2506d3d4f9b12eaf215f225'
	    || 'a223736f9fb4c42825d0497934c713f8c4618187ea7a6e987cd16efc1436876c'
	    || 'f1544107bedeee1456e9af27a04aa4413cf7c89992ecbae6dd67016d151682eb'
	    || 'a842eedffdba60b4f1907b7520e3030f24d8c29ee139673befa63fb871873054'
	    || 'b6f2cf3b9f326442cb15a4ccb01a4504f1e47d8d844a1be5bae7dfdc42cbda70'
	    || 'cd7dae0a57e85b7ad53f5af620cf4d8ccea4d42879d130a43486ebfb33d3cddc'
	    || '77853b5337effcb5c5068778e580b3e64e68b8f4c5c8b37e0d809ea2398feb7c'
	    || '132a4f9443b7950e2fee7d1c223613bddd06caa237df932bc4248289acf3ebc3'
	    || '5715f6b7ef3478ddf267616fc148cbe49052815e5e410fabb48a24652eda7fa4'
	    || 'e87b40e4e98ea0845889e9e1efd390fcdd07d35bdb48569438d7e5b257720101'
	    || '730edebc5b64311394917e4f503c2fba646f12827523d24ae0779695f9c17a8f'
	    || '7a5b2121d187b89629263a4dba510cdf81f47c9fad1163edea7b59651a00726e'
	    || '1140309200da6d774a0cdd61ad1f4603605bdfb09eedc36422ebe6a8cee7d28a'
	    || 'a0e736a05564a6b910853209c7eb8f372de705ca8951570fdf09822bbd691a6c'
	    || 'aa12e4f287451c0fe0f6a27a3ada48194cf1764f0d771c2b67cdb156350d8384'
	    || '5938fa0f42399ef336997b070e84093d4aa93e618360d87b1fa98b0c1149382c'
	    || 'e97625a50614d1b70e25244b0c768347589e8d820d2059d1a466bb1ef8da0a82'
	    || '04f19130ba6e4ec0992651641ee7230d50b2ad80eaee68018db2a283ea8bf59e'
	    , S8
	    );
    x := rpad( key, 32,	'0' );
    fill_subkey( km );
    fill_subkey( kr );
    for	i in 1 .. 16
    loop
      kr(i) := bitand( kr(i), 31 );
    end	loop;
  end;
--
  function f1( I number, m number, r number )
  return number
  is
    t varchar2(8);
  begin
    t := to_char( rol32( i + m,	r ), 'fm0XXXXXXX' );
    return bitxor( S1( substr( t, 1, 2 ) )
		 , S2( substr( t, 3, 2 ) )
		 )
	 - S3( substr( t, 5, 2 ) )
	 + S4( substr( t, 7, 2 ) );
  end;
--
  function f2( I number, m number, r number )
  return number
  is
    t varchar2(8);
  begin
    t := to_char( rol32( bitxor( i ,m ), r ), 'fm0XXXXXXX' );
    return bitxor( S1( substr( t, 1, 2 ) )
		 - S2( substr( t, 3, 2 ) )
		 + S3( substr( t, 5, 2 ) )
		 , S4( substr( t, 7, 2 ) )
		 );
  end;
--
  function f3( I number, m number, r number )
  return number
  is
    t varchar2(8);
  begin
    t := to_char( rol32( m - i,	r ), 'fm0XXXXXXX' );
    return bitxor( S1( substr( t, 1, 2 ) )
		 + S2( substr( t, 3, 2 ) )
		 , S3( substr( t, 5, 2 ) )
		 )
	 - S4( substr( t, 7, 2 ) );
  end;
--
  function cast128_encrypt( src	raw, key raw )
  return raw
  is
    L number;
    R number;
--
  begin
    L := to_number( utl_raw.substr( src, 1, 4 ), 'xxxxxxxx' );
    R := to_number( utl_raw.substr( src, 5, 4 ), 'xxxxxxxx' );
--
    L := bitand( bitxor( L, f1(	R, cast_Km(1), cast_Kr(1) ) ), bmax32 );
    R := bitand( bitxor( R, f2(	L, cast_Km(2), cast_Kr(2) ) ), bmax32 );
    L := bitand( bitxor( L, f3(	R, cast_Km(3), cast_Kr(3) ) ), bmax32 );
    R := bitand( bitxor( R, f1(	L, cast_Km(4), cast_Kr(4) ) ), bmax32 );
    L := bitand( bitxor( L, f2(	R, cast_Km(5), cast_Kr(5) ) ), bmax32 );
    R := bitand( bitxor( R, f3(	L, cast_Km(6), cast_Kr(6) ) ), bmax32 );
--
    L := bitand( bitxor( L, f1(	R, cast_Km(7), cast_Kr(7) ) ), bmax32 );
    R := bitand( bitxor( R, f2(	L, cast_Km(8), cast_Kr(8) ) ), bmax32 );
    L := bitand( bitxor( L, f3(	R, cast_Km(9), cast_Kr(9) ) ), bmax32 );
    R := bitand( bitxor( R, f1(	L, cast_Km(10),	cast_Kr(10) ) ), bmax32	);
    L := bitand( bitxor( L, f2(	R, cast_Km(11),	cast_Kr(11) ) ), bmax32	);
    R := bitand( bitxor( R, f3(	L, cast_Km(12),	cast_Kr(12) ) ), bmax32	);
--  dbms_output.put_line( 'LR '	|| to_char( L, 'fm0xxxxxxx' ) || ' ' ||	to_char( R, 'fm0xxxxxxx' ) );
--
    if utl_raw.length( key ) > 10
    then
      L	:= bitand( bitxor( L, f1( R, cast_Km(13), cast_Kr(13) )	), bmax32 );
      R	:= bitand( bitxor( R, f2( L, cast_Km(14), cast_Kr(14) )	), bmax32 );
      L	:= bitand( bitxor( L, f3( R, cast_Km(15), cast_Kr(15) )	), bmax32 );
      R	:= bitand( bitxor( R, f1( L, cast_Km(16), cast_Kr(16) )	), bmax32 );
    end	if;
--
    return to_char( R, 'fm0xxxxxxx' ) || to_char( L, 'fm0xxxxxxx' );
  end;
--
  function cast128_decrypt( src	raw, key raw )
  return raw
  is
    L number;
    R number;
--
  begin
    L := to_number( utl_raw.substr( src, 1, 4 ), 'xxxxxxxx' );
    R := to_number( utl_raw.substr( src, 5, 4 ), 'xxxxxxxx' );
--
    if utl_raw.length( key ) > 10
    then
      L	:= bitand( bitxor( L, f1( R, cast_Km(16), cast_Kr(16) )	), bmax32 );
      R	:= bitand( bitxor( R, f3( L, cast_Km(15), cast_Kr(15) )	), bmax32 );
      L	:= bitand( bitxor( L, f2( R, cast_Km(14), cast_Kr(14) )	), bmax32 );
      R	:= bitand( bitxor( R, f1( L, cast_Km(13), cast_Kr(13) )	), bmax32 );
    end	if;
--
    L := bitand( bitxor( L, f3(	R, cast_Km(12),	cast_Kr(12) ) ), bmax32	);
    R := bitand( bitxor( R, f2(	L, cast_Km(11),	cast_Kr(11) ) ), bmax32	);
    L := bitand( bitxor( L, f1(	R, cast_Km(10),	cast_Kr(10) ) ), bmax32	);
    R := bitand( bitxor( R, f3(	L, cast_Km(9), cast_Kr(9) ) ), bmax32 );
    L := bitand( bitxor( L, f2(	R, cast_Km(8), cast_Kr(8) ) ), bmax32 );
    R := bitand( bitxor( R, f1(	L, cast_Km(7), cast_Kr(7) ) ), bmax32 );
--
    L := bitand( bitxor( L, f3(	R, cast_Km(6), cast_Kr(6) ) ), bmax32 );
    R := bitand( bitxor( R, f2(	L, cast_Km(5), cast_Kr(5) ) ), bmax32 );
    L := bitand( bitxor( L, f1(	R, cast_Km(4), cast_Kr(4) ) ), bmax32 );
    R := bitand( bitxor( R, f3(	L, cast_Km(3), cast_Kr(3) ) ), bmax32 );
    L := bitand( bitxor( L, f2(	R, cast_Km(2), cast_Kr(2) ) ), bmax32 );
    R := bitand( bitxor( R, f1(	L, cast_Km(1), cast_Kr(1) ) ), bmax32 );
--
    return to_char( R, 'fm0xxxxxxx' ) || to_char( L, 'fm0xxxxxxx' );
  end;
--
  function encrypt( src	raw, typ pls_integer, key raw, iv raw := null )
  return raw
  is
  begin
    cast_key( key, cast_km, cast_kr );
    return cast128_encrypt( src, key );
  end;
--
  function decrypt( src	raw, typ pls_integer, key raw, iv raw := null )
  return raw
  is
  begin
    cast_key( key, cast_km, cast_kr );
    return cast128_decrypt( src, key );
  end;
begin
  t_key	:= '0123456712345678234567893456789A';
--  t_key := '01234567123456782345';
--  t_key := '0123456712';
  t_encr := encrypt( '0123456789ABCDEF', 0, t_key );
  dbms_output.put_line(	decrypt( t_encr, 0, t_key ) );
end;


declare
x number;
y varchar2(1000);
cnt pls_integer	:= 10000;
ts timestamp;
--
  function my_crc32( p_src raw,	p_init number := 0 )
  return number
  is
    l_crc32 number := 4294967295 - coalesce( p_init, 0 );
    l_src varchar(32766);
    l_len number;
    l_lop number;
    l_rop number;
    l_tmp number;
    l_chr number;
    l_crc constant varchar2(2048) :=
       '0000000077073096ee0e612c990951ba076dc419706af48fe963a5359e6495a3'
    || '0edb883279dcb8a4e0d5e91e97d2d98809b64c2b7eb17cbde7b82d0790bf1d91'
    || '1db710646ab020f2f3b9714884be41de1adad47d6ddde4ebf4d4b55183d385c7'
    || '136c9856646ba8c0fd62f97a8a65c9ec14015c4f63066cd9fa0f3d638d080df5'
    || '3b6e20c84c69105ed56041e4a26771723c03e4d14b04d447d20d85fda50ab56b'
    || '35b5a8fa42b2986cdbbbc9d6acbcf94032d86ce345df5c75dcd60dcfabd13d59'
    || '26d930ac51de003ac8d75180bfd0611621b4f4b556b3c423cfba9599b8bda50f'
    || '2802b89e5f058808c60cd9b2b10be9242f6f7c8758684c11c1611dabb6662d3d'
    || '76dc419001db710698d220bcefd5102a71b1858906b6b51f9fbfe4a5e8b8d433'
    || '7807c9a20f00f9349609a88ee10e98187f6a0dbb086d3d2d91646c97e6635c01'
    || '6b6b51f41c6c6162856530d8f262004e6c0695ed1b01a57b8208f4c1f50fc457'
    || '65b0d9c612b7e9508bbeb8eafcb9887c62dd1ddf15da2d498cd37cf3fbd44c65'
    || '4db261583ab551cea3bc0074d4bb30e24adfa5413dd895d7a4d1c46dd3d6f4fb'
    || '4369e96a346ed9fcad678846da60b8d044042d7333031de5aa0a4c5fdd0d7cc9'
    || '5005713c270241aabe0b1010c90c20865768b525206f85b3b966d409ce61e49f'
    || '5edef90e29d9c998b0d09822c7d7a8b459b33d172eb40d81b7bd5c3bc0ba6cad'
    || 'edb883209abfb3b603b6e20c74b1d29aead547399dd277af04db261573dc1683'
    || 'e3630b1294643b840d6d6a3e7a6a5aa8e40ecf0b9309ff9d0a00ae277d079eb1'
    || 'f00f93448708a3d21e01f2686906c2fef762575d806567cb196c36716e6b06e7'
    || 'fed41b7689d32be010da7a5a67dd4accf9b9df6f8ebeeff917b7be4360b08ed5'
    || 'd6d6a3e8a1d1937e38d8c2c44fdff252d1bb67f1a6bc57673fb506dd48b2364b'
    || 'd80d2bdaaf0a1b4c36034af641047a60df60efc3a867df55316e8eef4669be79'
    || 'cb61b38cbc66831a256fd2a05268e236cc0c7795bb0b4703220216b95505262f'
    || 'c5ba3bbeb2bd0b282bb45a925cb36a04c2d7ffa7b5d0cf312cd99e8b5bdeae1d'
    || '9b64c2b0ec63f226756aa39c026d930a9c0906a9eb0e363f7207678505005713'
    || '95bf4a82e2b87a147bb12bae0cb61b3892d28e9be5d5be0d7cdcefb70bdbdf21'
    || '86d3d2d4f1d4e24268ddb3f81fda836e81be16cdf6b9265b6fb077e118b74777'
    || '88085ae6ff0f6a7066063bca11010b5c8f659efff862ae69616bffd3166ccf45'
    || 'a00ae278d70dd2ee4e0483543903b3c2a7672661d06016f74969474d3e6e77db'
    || 'aed16a4ad9d65adc40df0b6637d83bf0a9bcae53debb9ec547b2cf7f30b5ffe9'
    || 'bdbdf21ccabac28a53b3933024b4a3a6bad03605cdd7069354de572923d967bf'
    || 'b3667a2ec4614ab85d681b022a6f2b94b40bbe37c30c8ea15a05df1b2d02ef8d';
  begin
    l_len := utl_raw.length( p_src );
    for	i in 0 .. trunc( ( l_len - 1 ) / 16383 )
    loop
      l_src := utl_raw.substr( p_src, 1	+ i * 16383, least( l_len - i *	16383, 16383 ) );
      for j in 1 .. length( l_src ) / 2
      loop
	l_chr := to_number( substr( l_src, j * 2 - 1, 2	), 'xx'	);
	l_lop := trunc(	l_crc32	/ 256 );
	l_tmp := bitand( l_crc32, l_chr	);
	l_rop := to_number( substr( l_crc
				  , bitand( l_crc32 + l_chr - 2	* l_tmp, 255 ) * 8 + 1
				  , 8
				  )
			  , 'xxxxxxxx'
			  );
	l_tmp := bitand( l_lop,	l_rop );
	l_crc32	:= l_lop + l_rop - 2 * l_tmp;
      end loop;
    end	loop;
    return 4294967295 -	l_crc32;
  end;
--
-- note	this uses another polynome!!!
  function fast_crc32( p_src raw, p_init number	:= 0 )
  return number
  is
    l_crc32 number := 4294967295 - coalesce( p_init, 0 );
  begin
    l_crc32 := l_crc32 - utl_raw.cast_to_binary_integer( utl_raw.substr( utl_compress.lz_compress( p_src ), -8,	4 ), utl_raw.little_endian );
    return 4294967295 -	l_crc32;
  end;
BEGIN
  y := 'Dit is een hele, hele, hele, grote test, maar dan anders!';
    x := utl_raw.cast_to_binary_integer( utl_raw.substr( utl_compress.lz_compress( utl_raw.cast_to_raw(	y ) ), -8, 4 ),	utl_raw.little_endian );
dbms_output.put_line( to_char( x, 'fm0xxxxxxx' ) );
    x := my_crc32( utl_raw.cast_to_raw(	y ) );
dbms_output.put_line( to_char( x, 'fm0xxxxxxx' ) );
    x := my_crc32( utl_raw.cast_to_raw(	substr(	y, 1, 10 ) ) );
    x := my_crc32( utl_raw.cast_to_raw(	substr(	y, 11 )	), x );
dbms_output.put_line( to_char( x, 'fm0xxxxxxx' ) );
    x := fast_crc32( utl_raw.cast_to_raw( y ) );
dbms_output.put_line( to_char( x, 'fm0xxxxxxx' ) );
END;




declare
  function PBKDF1
    ( passPhrase varchar2
    , saltValue	raw
    , hashAlgorithm varchar2 :=	'SHA1'
    , iterations pls_integer :=	1
    )
  return raw
  is
    rv raw(1000);
    htype pls_integer := case hashAlgorithm
			   when	'MD5'  then dbms_crypto.hash_md5
			   when	'SHA1' then dbms_crypto.hash_sh1
			 end;
  begin
    rv := dbms_crypto.hash( utl_raw.concat( utl_i18n.string_to_raw( passPhrase )
					  , saltValue
					  )
			  , htype
			  );
    for	i in 1 .. iterations - 1
    loop
      rv := dbms_crypto.hash( rv, htype	);
    end	loop;
    return rv;
  end;
--
  function PasswordDeriveBytes
    ( passPhrase varchar2
    , saltValue	raw
    , hashAlgorithm varchar2 :=	'SHA1'
    , iterations pls_integer :=	100
    , len pls_integer := null
    )
  return raw
  is
    rv raw(1000);
    tmp	raw(1000);
    htype pls_integer := case hashAlgorithm
			   when	'MD5'  then dbms_crypto.hash_md5
			   when	'SHA1' then dbms_crypto.hash_sh1
			 end;
  begin
    tmp	:= dbms_crypto.hash( utl_raw.concat( utl_i18n.string_to_raw( passPhrase	)
					   , saltValue
					   )
			   , htype
			   );
    for	i in 1 .. iterations - 2
    loop
      tmp := dbms_crypto.hash( tmp, htype );
    end	loop;
    rv := dbms_crypto.hash( tmp, htype );
    if len is not null
    then
      for i in 1 .. trunc( ( len - 1 ) / utl_raw.length( rv ) )
      loop
	rv := utl_raw.concat( rv, dbms_crypto.hash( utl_raw.concat( utl_raw.cast_to_raw( i ), tmp ), htype ) );
      end loop;
      rv := utl_raw.substr( rv,	1, len );
    end	if;
    return rv;
  end;
begin
  dbms_output.put_line(	PasswordDeriveBytes( '12345678password', '476F6E7A616C6F20536F7361', 'SHA1', 100, 48 ) );
end;
declare
  t_pw varchar2(100);
  t_salt raw(100);
  t_hash raw(100);
--
  function pbkdf2r( rpw raw, rsalt raw, rlen pls_integer, iterations pls_integer )
  return raw
  is
    rv raw(3999);
    tmp raw(100);
    tmp_xor raw(100);
    htyp pls_integer;
  begin
    htyp := dbms_crypto.hmac_sh1; 
    for i in 1 .. 1000
    loop
      tmp := dbms_crypto.mac( utl_raw.concat( rsalt
                                            , to_char( i, 'fm0XXXXXXX' )
                                            )
                            , htyp
                            , rpw
                            );
      tmp_xor := tmp; 
      for c in 2 .. iterations
      loop      
        tmp := dbms_crypto.mac( tmp, htyp, rpw );
        tmp_xor := utl_raw.bit_xor( tmp, tmp_xor ); 
      end loop;
      rv := utl_raw.concat( rv, tmp_xor );
      exit when utl_raw.length( rv ) >= rlen;
    end loop;
    return utl_raw.substr( rv, 1, rlen );
  end;
  function pbkdf2( pw varchar2, rsalt raw, rlen pls_integer, iterations pls_integer )
  return raw
  is
  begin
   return pbkdf2r( utl_i18n.string_to_raw( pw, 'AL32UTF8' ), rsalt, rlen, iterations );
  end;
begin
  t_pw := 'passwordPASSWORDpassword'; 
  t_salt := dbms_crypto.randombytes( 32 );
  t_hash := pbkdf2( t_pw, t_salt, 25, 4096 );
end;


declare
  function md2(	p_msg raw )
  return raw
  is
    m number;
    b varchar2(32);
    L number :=	0;
    type tp_md2	is table of number index by pls_integer;
    C tp_md2;
    S tp_md2;
    X tp_md2;
    Si varchar2(512) :=
       '292E43C9A2D87C013D3654A1ECF0061362A705F3C0C7738C98932BD9BC4C82CA'
    || '1E9B573CFDD4E01667426F188A17E512BE4EC4D6DA9EDE49A0FBF58EBB2FEE7A'
    || 'A968799115B2073F94C210890B225F21807F5D9A5A903227353ECCE7BFF79703'
    || 'FF1930B348A5B5D1D75E922AAC56AAC64FB838D296A47DB676FC6BE29C7404F1'
    || '459D705964718720865BCF65E62DA8021B6025ADAEB0B9F61C46616934407E0F'
    || '5547A323DD51AF3AC35CF9CEBAC5EA262C530D6E85288409D3DFCDF441814D52'
    || '6ADC37C86CC1ABFA24E17B080CBDB14A7888958BE363E86DE9CBD5FE3B001D39'
    || 'F2EFB70E6658D0E4A67772F8EB754B0A314450B48FED1F1ADB998D339F118314';
--
    function bitxor( x number, y number	)
    return number
    is
    begin
      return x + y - 2 * bitand( x, y );
    end;
--
    procedure checksum(	p_b varchar2 )
    is
      t	number;
    begin
      for i in 0 .. 15
      loop
	t := to_number(	substr(	p_b, i * 2 + 1,	2 ), 'xx' );
	C(i) :=	bitxor(	C(i), S( bitand( bitxor( t, L ), 255 ) ) );
	L := C(i);
      end loop;
    end;
--
    procedure process_block( p_b varchar2 )
    is
      t	number;
    begin
      for i in 0 .. 15
      loop
	t := to_number(	substr(	p_b, i * 2 + 1,	2 ), 'xx' );
	X( i + 16 ) := t;
	X( i + 32 ) := bitand( bitxor( t, X(i) ), 255 );
      end loop;
      t	:= 0;
      for j in 0 .. 17
      loop
	for k in 0 .. 47
	loop
	  X(k) := bitxor( X(k),	S(t) );
	  t := bitand( X(k), 255 );
	end loop;
	t := bitand( t + j, 255	);
      end loop;
    end;
  begin
    for	i in 0 .. 15
    loop
      C(i) := 0;
      X(i) := 0;
    end	loop;
    for	i in 0 .. 255
    loop
       S(i) := to_number( substr( Si, i	* 2 + 1, 2 ), 'xx' );
    end	loop;
--
    for	i in 0 .. nvl( trunc( (	utl_raw.length(	p_msg )	) / 16 ), 0 ) -	1
    loop
      b	:= utl_raw.substr( p_msg, i * 16 + 1, 16 );
      checksum(	b );
      process_block( b );
    end	loop;
    m := nvl( mod( utl_raw.length( p_msg ), 16 ), 0 );
    if m = 0
    then
      b	:= '';
    else
      b	:= utl_raw.substr( p_msg, -m );
    end	if;
    for	i in 1 .. 16 - m
    loop
      b	:= b ||	to_char( 16 - m, 'fm0X'	);
    end	loop;
    checksum( b	);
    process_block( b );
    b := '';
    for	i in 0 .. 15
    loop
      b	:= b ||	to_char( C(i), 'fm0X' );
    end	loop;
    process_block( b );
    b := '';
    for	i in 0 .. 15
    loop
      b	:= b ||	to_char( X(i), 'fm0X' );
    end	loop;
    return b;
  end;
begin
  dbms_output.put_line(	md2( utl_raw.cast_to_raw( 'abcdefghijklmnopqrstuvwxyz' ) ) );
  dbms_output.put_line(	md2( utl_raw.cast_to_raw( '1234567890123456' ) ) );
  dbms_output.put_line(	md2( utl_raw.cast_to_raw( 'abc'	) ) );
  dbms_output.put_line(	md2( utl_raw.cast_to_raw( '' ) ) );
end;
